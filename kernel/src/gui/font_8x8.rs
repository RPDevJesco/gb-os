//! 8x8 Bitmap Font - Platform Agnostic
//!
//! A simple monospace bitmap font for text rendering.
//! Each character is 8x8 pixels, stored as 8 bytes (one per row).
//! MSB is the leftmost pixel in each row.
//!
//! All buffer-based functions take a `pitch` parameter instead of
//! assuming a fixed screen width.

#[cfg(target_arch = "x86")]
use crate::graphics::vga_mode13h::{self, SCREEN_WIDTH};
#[cfg(target_arch = "x86")]
pub use crate::graphics::vga_mode13h::colors;

#[cfg(not(target_arch = "x86"))]
pub const SCREEN_WIDTH: usize = 320;
#[cfg(not(target_arch = "x86"))]
pub mod colors {
    pub const BLACK: u8 = 0x00;
    pub const BLUE: u8 = 0x01;
    pub const DARK_GREEN: u8 = 0x02;
    pub const CYAN: u8 = 0x03;
    pub const RED: u8 = 0x04;
    pub const MAGENTA: u8 = 0x05;
    pub const BROWN: u8 = 0x06;
    pub const LIGHT_GRAY: u8 = 0x07;
    pub const DARK_GRAY: u8 = 0x08;
    pub const LIGHT_BLUE: u8 = 0x09;
    pub const GREEN: u8 = 0x0A;
    pub const LIGHT_CYAN: u8 = 0x0B;
    pub const LIGHT_RED: u8 = 0x0C;
    pub const LIGHT_MAGENTA: u8 = 0x0D;
    pub const YELLOW: u8 = 0x0E;
    pub const WHITE: u8 = 0x0F;
    pub const LIGHT_GREEN: u8 = 0x2A;
    pub const HIGHLIGHT_BG: u8 = 0x02;
}

// ============================================================================
// Font Constants
// ============================================================================

/// Number of characters in the font
pub const CHAR_COUNT: usize = 256;

/// Character width in pixels
pub const CHAR_WIDTH: usize = 8;

/// Character height in pixels
pub const CHAR_HEIGHT: usize = 8;

// ============================================================================
// Font Data (full ASCII 0-255)
// ============================================================================

#[rustfmt::skip]
static FONT_DATA: [u8; CHAR_COUNT * CHAR_HEIGHT] = [
    // 0x00-0x1F: Control characters (mostly symbols)
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x00 Null
    0x7E, 0x81, 0xA5, 0x81, 0xBD, 0x99, 0x81, 0x7E, // 0x01 Smiley
    0x7E, 0xFF, 0xDB, 0xFF, 0xC3, 0xE7, 0xFF, 0x7E, // 0x02 Filled smiley
    0x6C, 0xFE, 0xFE, 0xFE, 0x7C, 0x38, 0x10, 0x00, // 0x03 Heart
    0x10, 0x38, 0x7C, 0xFE, 0x7C, 0x38, 0x10, 0x00, // 0x04 Diamond
    0x38, 0x7C, 0x38, 0xFE, 0xFE, 0x7C, 0x38, 0x7C, // 0x05 Club
    0x10, 0x10, 0x38, 0x7C, 0xFE, 0x7C, 0x38, 0x7C, // 0x06 Spade
    0x00, 0x00, 0x18, 0x3C, 0x3C, 0x18, 0x00, 0x00, // 0x07 Bullet
    0xFF, 0xFF, 0xE7, 0xC3, 0xC3, 0xE7, 0xFF, 0xFF, // 0x08 Inverse bullet
    0x00, 0x3C, 0x66, 0x42, 0x42, 0x66, 0x3C, 0x00, // 0x09 Circle
    0xFF, 0xC3, 0x99, 0xBD, 0xBD, 0x99, 0xC3, 0xFF, // 0x0A Inverse circle
    0x0F, 0x07, 0x0F, 0x7D, 0xCC, 0xCC, 0xCC, 0x78, // 0x0B Male
    0x3C, 0x66, 0x66, 0x66, 0x3C, 0x18, 0x7E, 0x18, // 0x0C Female
    0x3F, 0x33, 0x3F, 0x30, 0x30, 0x70, 0xF0, 0xE0, // 0x0D Note
    0x7F, 0x63, 0x7F, 0x63, 0x63, 0x67, 0xE6, 0xC0, // 0x0E Sun
    0x99, 0x5A, 0x3C, 0xE7, 0xE7, 0x3C, 0x5A, 0x99, // 0x0F Star
    0x80, 0xE0, 0xF8, 0xFE, 0xF8, 0xE0, 0x80, 0x00, // 0x10 Right triangle
    0x02, 0x0E, 0x3E, 0xFE, 0x3E, 0x0E, 0x02, 0x00, // 0x11 Left triangle
    0x18, 0x3C, 0x7E, 0x18, 0x18, 0x7E, 0x3C, 0x18, // 0x12 Up-down arrow
    0x66, 0x66, 0x66, 0x66, 0x66, 0x00, 0x66, 0x00, // 0x13 Double exclaim
    0x7F, 0xDB, 0xDB, 0x7B, 0x1B, 0x1B, 0x1B, 0x00, // 0x14 Paragraph
    0x3E, 0x63, 0x38, 0x6C, 0x6C, 0x38, 0xCC, 0x78, // 0x15 Section
    0x00, 0x00, 0x00, 0x00, 0x7E, 0x7E, 0x7E, 0x00, // 0x16 Thick underline
    0x18, 0x3C, 0x7E, 0x18, 0x7E, 0x3C, 0x18, 0xFF, // 0x17 Up-down arrow underline
    0x18, 0x3C, 0x7E, 0x18, 0x18, 0x18, 0x18, 0x00, // 0x18 Up arrow
    0x18, 0x18, 0x18, 0x18, 0x7E, 0x3C, 0x18, 0x00, // 0x19 Down arrow
    0x00, 0x18, 0x0C, 0xFE, 0x0C, 0x18, 0x00, 0x00, // 0x1A Right arrow
    0x00, 0x30, 0x60, 0xFE, 0x60, 0x30, 0x00, 0x00, // 0x1B Left arrow
    0x00, 0x00, 0xC0, 0xC0, 0xC0, 0xFE, 0x00, 0x00, // 0x1C Corner
    0x00, 0x24, 0x66, 0xFF, 0x66, 0x24, 0x00, 0x00, // 0x1D Left-right arrow
    0x00, 0x18, 0x3C, 0x7E, 0xFF, 0xFF, 0x00, 0x00, // 0x1E Up triangle
    0x00, 0xFF, 0xFF, 0x7E, 0x3C, 0x18, 0x00, 0x00, // 0x1F Down triangle

    // 0x20-0x7F: Standard ASCII printable characters
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x20 Space
    0x18, 0x3C, 0x3C, 0x18, 0x18, 0x00, 0x18, 0x00, // 0x21 !
    0x66, 0x66, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x22 "
    0x6C, 0x6C, 0xFE, 0x6C, 0xFE, 0x6C, 0x6C, 0x00, // 0x23 #
    0x18, 0x7E, 0xC0, 0x7C, 0x06, 0xFC, 0x18, 0x00, // 0x24 $
    0x00, 0xC6, 0xCC, 0x18, 0x30, 0x66, 0xC6, 0x00, // 0x25 %
    0x38, 0x6C, 0x38, 0x76, 0xDC, 0xCC, 0x76, 0x00, // 0x26 &
    0x30, 0x30, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x27 '
    0x0C, 0x18, 0x30, 0x30, 0x30, 0x18, 0x0C, 0x00, // 0x28 (
    0x30, 0x18, 0x0C, 0x0C, 0x0C, 0x18, 0x30, 0x00, // 0x29 )
    0x00, 0x66, 0x3C, 0xFF, 0x3C, 0x66, 0x00, 0x00, // 0x2A *
    0x00, 0x18, 0x18, 0x7E, 0x18, 0x18, 0x00, 0x00, // 0x2B +
    0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x30, // 0x2C ,
    0x00, 0x00, 0x00, 0x7E, 0x00, 0x00, 0x00, 0x00, // 0x2D -
    0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, // 0x2E .
    0x06, 0x0C, 0x18, 0x30, 0x60, 0xC0, 0x80, 0x00, // 0x2F /
    0x7C, 0xCE, 0xDE, 0xF6, 0xE6, 0xC6, 0x7C, 0x00, // 0x30 0
    0x18, 0x38, 0x18, 0x18, 0x18, 0x18, 0x7E, 0x00, // 0x31 1
    0x7C, 0xC6, 0x06, 0x1C, 0x30, 0x66, 0xFE, 0x00, // 0x32 2
    0x7C, 0xC6, 0x06, 0x3C, 0x06, 0xC6, 0x7C, 0x00, // 0x33 3
    0x1C, 0x3C, 0x6C, 0xCC, 0xFE, 0x0C, 0x1E, 0x00, // 0x34 4
    0xFE, 0xC0, 0xC0, 0xFC, 0x06, 0xC6, 0x7C, 0x00, // 0x35 5
    0x38, 0x60, 0xC0, 0xFC, 0xC6, 0xC6, 0x7C, 0x00, // 0x36 6
    0xFE, 0xC6, 0x0C, 0x18, 0x30, 0x30, 0x30, 0x00, // 0x37 7
    0x7C, 0xC6, 0xC6, 0x7C, 0xC6, 0xC6, 0x7C, 0x00, // 0x38 8
    0x7C, 0xC6, 0xC6, 0x7E, 0x06, 0x0C, 0x78, 0x00, // 0x39 9
    0x00, 0x18, 0x18, 0x00, 0x00, 0x18, 0x18, 0x00, // 0x3A :
    0x00, 0x18, 0x18, 0x00, 0x00, 0x18, 0x18, 0x30, // 0x3B ;
    0x06, 0x0C, 0x18, 0x30, 0x18, 0x0C, 0x06, 0x00, // 0x3C <
    0x00, 0x00, 0x7E, 0x00, 0x00, 0x7E, 0x00, 0x00, // 0x3D =
    0x60, 0x30, 0x18, 0x0C, 0x18, 0x30, 0x60, 0x00, // 0x3E >
    0x7C, 0xC6, 0x0C, 0x18, 0x18, 0x00, 0x18, 0x00, // 0x3F ?
    0x7C, 0xC6, 0xDE, 0xDE, 0xDE, 0xC0, 0x78, 0x00, // 0x40 @
    0x38, 0x6C, 0xC6, 0xFE, 0xC6, 0xC6, 0xC6, 0x00, // 0x41 A
    0xFC, 0x66, 0x66, 0x7C, 0x66, 0x66, 0xFC, 0x00, // 0x42 B
    0x3C, 0x66, 0xC0, 0xC0, 0xC0, 0x66, 0x3C, 0x00, // 0x43 C
    0xF8, 0x6C, 0x66, 0x66, 0x66, 0x6C, 0xF8, 0x00, // 0x44 D
    0xFE, 0x62, 0x68, 0x78, 0x68, 0x62, 0xFE, 0x00, // 0x45 E
    0xFE, 0x62, 0x68, 0x78, 0x68, 0x60, 0xF0, 0x00, // 0x46 F
    0x3C, 0x66, 0xC0, 0xC0, 0xCE, 0x66, 0x3A, 0x00, // 0x47 G
    0xC6, 0xC6, 0xC6, 0xFE, 0xC6, 0xC6, 0xC6, 0x00, // 0x48 H
    0x3C, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00, // 0x49 I
    0x1E, 0x0C, 0x0C, 0x0C, 0xCC, 0xCC, 0x78, 0x00, // 0x4A J
    0xE6, 0x66, 0x6C, 0x78, 0x6C, 0x66, 0xE6, 0x00, // 0x4B K
    0xF0, 0x60, 0x60, 0x60, 0x62, 0x66, 0xFE, 0x00, // 0x4C L
    0xC6, 0xEE, 0xFE, 0xFE, 0xD6, 0xC6, 0xC6, 0x00, // 0x4D M
    0xC6, 0xE6, 0xF6, 0xDE, 0xCE, 0xC6, 0xC6, 0x00, // 0x4E N
    0x7C, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0x7C, 0x00, // 0x4F O
    0xFC, 0x66, 0x66, 0x7C, 0x60, 0x60, 0xF0, 0x00, // 0x50 P
    0x7C, 0xC6, 0xC6, 0xC6, 0xD6, 0x7C, 0x0E, 0x00, // 0x51 Q
    0xFC, 0x66, 0x66, 0x7C, 0x6C, 0x66, 0xE6, 0x00, // 0x52 R
    0x7C, 0xC6, 0xE0, 0x78, 0x0E, 0xC6, 0x7C, 0x00, // 0x53 S
    0x7E, 0x7E, 0x5A, 0x18, 0x18, 0x18, 0x3C, 0x00, // 0x54 T
    0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0x7C, 0x00, // 0x55 U
    0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0x6C, 0x38, 0x00, // 0x56 V
    0xC6, 0xC6, 0xC6, 0xD6, 0xD6, 0xFE, 0x6C, 0x00, // 0x57 W
    0xC6, 0xC6, 0x6C, 0x38, 0x6C, 0xC6, 0xC6, 0x00, // 0x58 X
    0x66, 0x66, 0x66, 0x3C, 0x18, 0x18, 0x3C, 0x00, // 0x59 Y
    0xFE, 0xC6, 0x8C, 0x18, 0x32, 0x66, 0xFE, 0x00, // 0x5A Z
    0x3C, 0x30, 0x30, 0x30, 0x30, 0x30, 0x3C, 0x00, // 0x5B [
    0xC0, 0x60, 0x30, 0x18, 0x0C, 0x06, 0x02, 0x00, // 0x5C backslash
    0x3C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x3C, 0x00, // 0x5D ]
    0x10, 0x38, 0x6C, 0xC6, 0x00, 0x00, 0x00, 0x00, // 0x5E ^
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, // 0x5F _
    0x30, 0x30, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x60 `
    0x00, 0x00, 0x78, 0x0C, 0x7C, 0xCC, 0x76, 0x00, // 0x61 a
    0xE0, 0x60, 0x60, 0x7C, 0x66, 0x66, 0xDC, 0x00, // 0x62 b
    0x00, 0x00, 0x78, 0xCC, 0xC0, 0xCC, 0x78, 0x00, // 0x63 c
    0x1C, 0x0C, 0x0C, 0x7C, 0xCC, 0xCC, 0x76, 0x00, // 0x64 d
    0x00, 0x00, 0x78, 0xCC, 0xFC, 0xC0, 0x78, 0x00, // 0x65 e
    0x38, 0x6C, 0x64, 0xF0, 0x60, 0x60, 0xF0, 0x00, // 0x66 f
    0x00, 0x00, 0x76, 0xCC, 0xCC, 0x7C, 0x0C, 0xF8, // 0x67 g
    0xE0, 0x60, 0x6C, 0x76, 0x66, 0x66, 0xE6, 0x00, // 0x68 h
    0x18, 0x00, 0x38, 0x18, 0x18, 0x18, 0x3C, 0x00, // 0x69 i
    0x06, 0x00, 0x06, 0x06, 0x06, 0x66, 0x66, 0x3C, // 0x6A j
    0xE0, 0x60, 0x66, 0x6C, 0x78, 0x6C, 0xE6, 0x00, // 0x6B k
    0x38, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00, // 0x6C l
    0x00, 0x00, 0xEC, 0xFE, 0xD6, 0xD6, 0xC6, 0x00, // 0x6D m
    0x00, 0x00, 0xDC, 0x66, 0x66, 0x66, 0x66, 0x00, // 0x6E n
    0x00, 0x00, 0x78, 0xCC, 0xCC, 0xCC, 0x78, 0x00, // 0x6F o
    0x00, 0x00, 0xDC, 0x66, 0x66, 0x7C, 0x60, 0xF0, // 0x70 p
    0x00, 0x00, 0x76, 0xCC, 0xCC, 0x7C, 0x0C, 0x1E, // 0x71 q
    0x00, 0x00, 0xDC, 0x76, 0x66, 0x60, 0xF0, 0x00, // 0x72 r
    0x00, 0x00, 0x7C, 0xC0, 0x70, 0x1C, 0xF8, 0x00, // 0x73 s
    0x10, 0x30, 0x7C, 0x30, 0x30, 0x34, 0x18, 0x00, // 0x74 t
    0x00, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0x76, 0x00, // 0x75 u
    0x00, 0x00, 0xCC, 0xCC, 0xCC, 0x78, 0x30, 0x00, // 0x76 v
    0x00, 0x00, 0xC6, 0xC6, 0xD6, 0xFE, 0x6C, 0x00, // 0x77 w
    0x00, 0x00, 0xC6, 0x6C, 0x38, 0x6C, 0xC6, 0x00, // 0x78 x
    0x00, 0x00, 0xCC, 0xCC, 0xCC, 0x7C, 0x0C, 0xF8, // 0x79 y
    0x00, 0x00, 0xFC, 0x98, 0x30, 0x64, 0xFC, 0x00, // 0x7A z
    0x1C, 0x30, 0x30, 0xE0, 0x30, 0x30, 0x1C, 0x00, // 0x7B {
    0x18, 0x18, 0x18, 0x00, 0x18, 0x18, 0x18, 0x00, // 0x7C |
    0xE0, 0x30, 0x30, 0x1C, 0x30, 0x30, 0xE0, 0x00, // 0x7D }
    0x76, 0xDC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x7E ~
    0x00, 0x10, 0x38, 0x6C, 0xC6, 0xC6, 0xFE, 0x00, // 0x7F DEL

    // 0x80-0xFF: Extended ASCII (block graphics, accented chars, etc.)
    // For now, fill with empty glyphs - can be customized later
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x80
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x81
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x82
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x83
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x84
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x85
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x86
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x87
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x88
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x89
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x8A
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x8B
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x8C
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x8D
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x8E
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x8F
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x90
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x91
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x92
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x93
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x94
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x95
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x96
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x97
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x98
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x99
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x9A
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x9B
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x9C
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x9D
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x9E
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x9F
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xA0
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xA1
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xA2
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xA3
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xA4
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xA5
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xA6
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xA7
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xA8
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xA9
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xAA
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xAB
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xAC
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xAD
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xAE
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xAF
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xB0
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xB1
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xB2
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xB3
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xB4
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xB5
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xB6
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xB7
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xB8
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xB9
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xBA
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xBB
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xBC
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xBD
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xBE
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xBF
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xC0
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xC1
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xC2
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xC3
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xC4
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xC5
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xC6
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xC7
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xC8
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xC9
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xCA
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xCB
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xCC
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xCD
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xCE
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xCF
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xD0
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xD1
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xD2
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xD3
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xD4
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xD5
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xD6
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xD7
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xD8
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xD9
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xDA
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xDB
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xDC
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xDD
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xDE
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xDF
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xE0
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xE1
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xE2
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xE3
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xE4
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xE5
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xE6
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xE7
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xE8
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xE9
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xEA
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xEB
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xEC
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xED
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xEE
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xEF
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xF0
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xF1
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xF2
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xF3
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xF4
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xF5
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xF6
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xF7
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xF8
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xF9
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xFA
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xFB
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xFC
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xFD
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xFE
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xFF
];

// ============================================================================
// Font Access Functions
// ============================================================================

/// Get the bitmap data for a character as a fixed-size array
#[inline]
pub fn get_char_bitmap(ch: u8) -> [u8; 8] {
    let start = (ch as usize) * 8;
    [
        FONT_DATA[start],
        FONT_DATA[start + 1],
        FONT_DATA[start + 2],
        FONT_DATA[start + 3],
        FONT_DATA[start + 4],
        FONT_DATA[start + 5],
        FONT_DATA[start + 6],
        FONT_DATA[start + 7],
    ]
}

// ============================================================================
// Buffer-Based Rendering (Platform Agnostic)
//
// All functions take `pitch` (bytes per row) as a parameter
// ============================================================================

/// Draw a character bitmap to a buffer
///
/// # Arguments
/// * `buffer` - Pixel buffer (8-bit indexed)
/// * `pitch` - Bytes per row in the buffer
/// * `x`, `y` - Position
/// * `ch` - ASCII character
/// * `fg` - Foreground color
#[inline]
pub fn draw_char(buffer: &mut [u8], pitch: usize, x: usize, y: usize, ch: u8, fg: u8) {
    let bitmap = get_char_bitmap(ch);
    for (row, bits) in bitmap.iter().enumerate() {
        let py = y + row;
        for col in 0..CHAR_WIDTH {
            if (bits >> (7 - col)) & 1 != 0 {
                let px = x + col;
                let offset = py * pitch + px;
                if offset < buffer.len() {
                    buffer[offset] = fg;
                }
            }
        }
    }
}

/// Draw a character with background color
pub fn draw_char_bg(buffer: &mut [u8], pitch: usize, x: usize, y: usize, ch: u8, fg: u8, bg: u8) {
    let bitmap = get_char_bitmap(ch);
    for (row, bits) in bitmap.iter().enumerate() {
        let py = y + row;
        for col in 0..CHAR_WIDTH {
            let px = x + col;
            let offset = py * pitch + px;
            if offset < buffer.len() {
                buffer[offset] = if (bits >> (7 - col)) & 1 != 0 { fg } else { bg };
            }
        }
    }
}

/// Draw a string to a buffer
pub fn draw_str(buffer: &mut [u8], pitch: usize, x: usize, y: usize, s: &str, fg: u8) {
    let mut cx = x;
    for ch in s.bytes() {
        draw_char(buffer, pitch, cx, y, ch, fg);
        cx += CHAR_WIDTH;
    }
}

/// Draw a string with background color
pub fn draw_str_bg(buffer: &mut [u8], pitch: usize, x: usize, y: usize, s: &str, fg: u8, bg: u8) {
    let mut cx = x;
    for ch in s.bytes() {
        draw_char_bg(buffer, pitch, cx, y, ch, fg, bg);
        cx += CHAR_WIDTH;
    }
}

/// Draw a string centered horizontally
pub fn draw_str_centered(buffer: &mut [u8], pitch: usize, screen_width: usize, y: usize, s: &str, fg: u8) {
    let width = s.len() * CHAR_WIDTH;
    let x = screen_width.saturating_sub(width) / 2;
    draw_str(buffer, pitch, x, y, s, fg);
}

/// Draw an unsigned number
pub fn draw_number(buffer: &mut [u8], pitch: usize, x: usize, y: usize, n: u32, min_width: usize, fg: u8) {
    let mut digits = [0u8; 10];
    let mut num = n;
    let mut count = 0;

    loop {
        digits[count] = b'0' + (num % 10) as u8;
        count += 1;
        num /= 10;
        if num == 0 { break; }
    }

    let mut cx = x;
    // Pad with spaces
    if count < min_width {
        for _ in 0..(min_width - count) {
            draw_char(buffer, pitch, cx, y, b' ', fg);
            cx += CHAR_WIDTH;
        }
    }

    // Draw digits in reverse
    for i in (0..count).rev() {
        draw_char(buffer, pitch, cx, y, digits[i], fg);
        cx += CHAR_WIDTH;
    }
}

/// Draw a signed number
pub fn draw_signed(buffer: &mut [u8], pitch: usize, x: usize, y: usize, n: i32, min_width: usize, fg: u8) {
    if n < 0 {
        draw_char(buffer, pitch, x, y, b'-', fg);
        draw_number(buffer, pitch, x + CHAR_WIDTH, y, (-n) as u32, min_width.saturating_sub(1), fg);
    } else {
        draw_number(buffer, pitch, x, y, n as u32, min_width, fg);
    }
}

/// Draw a hexadecimal number
pub fn draw_hex(buffer: &mut [u8], pitch: usize, x: usize, y: usize, n: u32, digits: usize, fg: u8) {
    const HEX_CHARS: &[u8] = b"0123456789ABCDEF";
    let mut cx = x;
    for i in (0..digits).rev() {
        let nibble = ((n >> (i * 4)) & 0xF) as usize;
        draw_char(buffer, pitch, cx, y, HEX_CHARS[nibble], fg);
        cx += CHAR_WIDTH;
    }
}

/// Calculate pixel width of a string
#[inline]
pub fn string_width(s: &str) -> usize {
    s.len() * CHAR_WIDTH
}

// ============================================================================
// VGA-Direct Rendering (x86 only)
// ============================================================================

#[cfg(target_arch = "x86")]
pub mod vga {
    use super::*;
    use crate::graphics::vga_mode13h;

    const SCREEN_WIDTH: usize = 320;

    /// Draw character directly to VGA memory
    #[cfg(target_arch = "x86")]
    pub fn draw_char_vga(x: usize, y: usize, ch: u8, color: u8) {
        let bitmap = get_char_bitmap(ch);
        vga_mode13h::draw_bitmap_8x8(x, y, bitmap, color);
    }

    /// Draw string directly to VGA memory
    #[cfg(target_arch = "x86")]
    pub fn draw_string_vga(x: usize, y: usize, s: &str, color: u8) {
        let mut cx = x;
        for ch in s.bytes() {
            draw_char_vga(cx, y, ch, color);
            cx += CHAR_WIDTH;
        }
    }

    /// Draw string centered directly to VGA memory
    #[cfg(target_arch = "x86")]
    pub fn draw_string_centered_vga(y: usize, s: &str, color: u8) {
        let width = s.len() * CHAR_WIDTH;
        let x = SCREEN_WIDTH.saturating_sub(width) / 2;
        draw_string_vga(x, y, s, color);
    }
}
