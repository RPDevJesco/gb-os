//! 8x8 Bitmap Font
//!
//! A simple monospace bitmap font for VGA text rendering.
//! Each character is 8x8 pixels, stored as 8 bytes (one per row).
//! MSB is the leftmost pixel in each row.

use crate::graphics::vga_mode13h::{self, SCREEN_WIDTH};

// Re-export colors for compatibility with existing code
pub use crate::graphics::vga_mode13h::colors;

// ============================================================================
// Font Data
// ============================================================================

#[repr(align(16))]
struct FontData([u8; 256 * 8]);

/// Number of characters in the font
pub const CHAR_COUNT: usize = 256;

/// Character width in pixels
pub const CHAR_WIDTH: usize = 8;

/// Character height in pixels
pub const CHAR_HEIGHT: usize = 8;

/// Font character index mapping:
/// - 0-25:  A-Z (uppercase letters)
/// - 26-35: 0-9 (digits)
/// - 36:    Space
/// - 37:    . (period)
/// - 38:    : (colon)
/// - 39:    / (forward slash)
/// - 40:    - (hyphen)
/// - 41:    > (greater than / arrow)
/// - 42:    ^ (caret / up arrow)
/// - 43:    v (down arrow, displayed as V)
/// - 44:    _ (underscore)
#[rustfmt::skip]
static FONT_DATA: [u8; CHAR_COUNT * CHAR_HEIGHT] = [
    // 0x00 - Null (empty)
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    // 0x01 - SOH (smiley face)
    0x7E, 0x81, 0xA5, 0x81, 0xBD, 0x99, 0x81, 0x7E,
    // 0x02 - STX (filled smiley)
    0x7E, 0xFF, 0xDB, 0xFF, 0xC3, 0xE7, 0xFF, 0x7E,
    // 0x03 - ETX (heart)
    0x6C, 0xFE, 0xFE, 0xFE, 0x7C, 0x38, 0x10, 0x00,
    // 0x04 - EOT (diamond)
    0x10, 0x38, 0x7C, 0xFE, 0x7C, 0x38, 0x10, 0x00,
    // 0x05 - ENQ (club)
    0x38, 0x7C, 0x38, 0xFE, 0xFE, 0x7C, 0x38, 0x7C,
    // 0x06 - ACK (spade)
    0x10, 0x10, 0x38, 0x7C, 0xFE, 0x7C, 0x38, 0x7C,
    // 0x07 - BEL (bullet)
    0x00, 0x00, 0x18, 0x3C, 0x3C, 0x18, 0x00, 0x00,
    // 0x08 - BS (inverse bullet)
    0xFF, 0xFF, 0xE7, 0xC3, 0xC3, 0xE7, 0xFF, 0xFF,
    // 0x09 - HT (circle)
    0x00, 0x3C, 0x66, 0x42, 0x42, 0x66, 0x3C, 0x00,
    // 0x0A - LF (inverse circle)
    0xFF, 0xC3, 0x99, 0xBD, 0xBD, 0x99, 0xC3, 0xFF,
    // 0x0B - VT (male symbol)
    0x0F, 0x07, 0x0F, 0x7D, 0xCC, 0xCC, 0xCC, 0x78,
    // 0x0C - FF (female symbol)
    0x3C, 0x66, 0x66, 0x66, 0x3C, 0x18, 0x7E, 0x18,
    // 0x0D - CR (note)
    0x3F, 0x33, 0x3F, 0x30, 0x30, 0x70, 0xF0, 0xE0,
    // 0x0E - SO (sun)
    0x7F, 0x63, 0x7F, 0x63, 0x63, 0x67, 0xE6, 0xC0,
    // 0x0F - SI (star)
    0x99, 0x5A, 0x3C, 0xE7, 0xE7, 0x3C, 0x5A, 0x99,
    // 0x10 - DLE (right triangle)
    0x80, 0xE0, 0xF8, 0xFE, 0xF8, 0xE0, 0x80, 0x00,
    // 0x11 - DC1 (left triangle)
    0x02, 0x0E, 0x3E, 0xFE, 0x3E, 0x0E, 0x02, 0x00,
    // 0x12 - DC2 (up-down arrow)
    0x18, 0x3C, 0x7E, 0x18, 0x18, 0x7E, 0x3C, 0x18,
    // 0x13 - DC3 (double exclamation)
    0x66, 0x66, 0x66, 0x66, 0x66, 0x00, 0x66, 0x00,
    // 0x14 - DC4 (paragraph)
    0x7F, 0xDB, 0xDB, 0x7B, 0x1B, 0x1B, 0x1B, 0x00,
    // 0x15 - NAK (section)
    0x3E, 0x63, 0x38, 0x6C, 0x6C, 0x38, 0xCC, 0x78,
    // 0x16 - SYN (thick underline)
    0x00, 0x00, 0x00, 0x00, 0x7E, 0x7E, 0x7E, 0x00,
    // 0x17 - ETB (up-down arrow with base)
    0x18, 0x3C, 0x7E, 0x18, 0x7E, 0x3C, 0x18, 0xFF,
    // 0x18 - CAN (up arrow)
    0x18, 0x3C, 0x7E, 0x18, 0x18, 0x18, 0x18, 0x00,
    // 0x19 - EM (down arrow)
    0x18, 0x18, 0x18, 0x18, 0x7E, 0x3C, 0x18, 0x00,
    // 0x1A - SUB (right arrow)
    0x00, 0x18, 0x0C, 0xFE, 0x0C, 0x18, 0x00, 0x00,
    // 0x1B - ESC (left arrow)
    0x00, 0x30, 0x60, 0xFE, 0x60, 0x30, 0x00, 0x00,
    // 0x1C - FS (right angle)
    0x00, 0x00, 0xC0, 0xC0, 0xC0, 0xFE, 0x00, 0x00,
    // 0x1D - GS (left-right arrow)
    0x00, 0x24, 0x66, 0xFF, 0x66, 0x24, 0x00, 0x00,
    // 0x1E - RS (up triangle)
    0x00, 0x18, 0x3C, 0x7E, 0xFF, 0xFF, 0x00, 0x00,
    // 0x1F - US (down triangle)
    0x00, 0xFF, 0xFF, 0x7E, 0x3C, 0x18, 0x00, 0x00,
    // 0x20 - Space
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    // 0x21 - !
    0x18, 0x3C, 0x3C, 0x18, 0x18, 0x00, 0x18, 0x00,
    // 0x22 - "
    0x6C, 0x6C, 0x6C, 0x00, 0x00, 0x00, 0x00, 0x00,
    // 0x23 - #
    0x6C, 0x6C, 0xFE, 0x6C, 0xFE, 0x6C, 0x6C, 0x00,
    // 0x24 - $
    0x18, 0x7E, 0xC0, 0x7C, 0x06, 0xFC, 0x18, 0x00,
    // 0x25 - %
    0x00, 0xC6, 0xCC, 0x18, 0x30, 0x66, 0xC6, 0x00,
    // 0x26 - &
    0x38, 0x6C, 0x38, 0x76, 0xDC, 0xCC, 0x76, 0x00,
    // 0x27 - '
    0x30, 0x30, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00,
    // 0x28 - (
    0x18, 0x30, 0x60, 0x60, 0x60, 0x30, 0x18, 0x00,
    // 0x29 - )
    0x60, 0x30, 0x18, 0x18, 0x18, 0x30, 0x60, 0x00,
    // 0x2A - *
    0x00, 0x66, 0x3C, 0xFF, 0x3C, 0x66, 0x00, 0x00,
    // 0x2B - +
    0x00, 0x18, 0x18, 0x7E, 0x18, 0x18, 0x00, 0x00,
    // 0x2C - ,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x30,
    // 0x2D - -
    0x00, 0x00, 0x00, 0x7E, 0x00, 0x00, 0x00, 0x00,
    // 0x2E - .
    0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00,
    // 0x2F - /
    0x06, 0x0C, 0x18, 0x30, 0x60, 0xC0, 0x80, 0x00,
    // 0x30 - 0
    0x7C, 0xCE, 0xDE, 0xF6, 0xE6, 0xC6, 0x7C, 0x00,
    // 0x31 - 1
    0x18, 0x38, 0x18, 0x18, 0x18, 0x18, 0x7E, 0x00,
    // 0x32 - 2
    0x7C, 0xC6, 0x06, 0x7C, 0xC0, 0xC0, 0xFE, 0x00,
    // 0x33 - 3
    0x7C, 0xC6, 0x06, 0x3C, 0x06, 0xC6, 0x7C, 0x00,
    // 0x34 - 4
    0x1C, 0x3C, 0x6C, 0xCC, 0xFE, 0x0C, 0x0C, 0x00,
    // 0x35 - 5
    0xFE, 0xC0, 0xFC, 0x06, 0x06, 0xC6, 0x7C, 0x00,
    // 0x36 - 6
    0x7C, 0xC0, 0xC0, 0xFC, 0xC6, 0xC6, 0x7C, 0x00,
    // 0x37 - 7
    0xFE, 0x06, 0x06, 0x0C, 0x18, 0x18, 0x18, 0x00,
    // 0x38 - 8
    0x7C, 0xC6, 0xC6, 0x7C, 0xC6, 0xC6, 0x7C, 0x00,
    // 0x39 - 9
    0x7C, 0xC6, 0xC6, 0x7E, 0x06, 0x06, 0x7C, 0x00,
    // 0x3A - :
    0x00, 0x18, 0x18, 0x00, 0x00, 0x18, 0x18, 0x00,
    // 0x3B - ;
    0x00, 0x18, 0x18, 0x00, 0x00, 0x18, 0x18, 0x30,
    // 0x3C - <
    0x0C, 0x18, 0x30, 0x60, 0x30, 0x18, 0x0C, 0x00,
    // 0x3D - =
    0x00, 0x00, 0x7E, 0x00, 0x7E, 0x00, 0x00, 0x00,
    // 0x3E - >
    0x60, 0x30, 0x18, 0x0C, 0x18, 0x30, 0x60, 0x00,
    // 0x3F - ?
    0x7C, 0xC6, 0x0C, 0x18, 0x18, 0x00, 0x18, 0x00,
    // 0x40 - @
    0x7C, 0xC6, 0xDE, 0xDE, 0xDC, 0xC0, 0x7C, 0x00,
    // 0x41 - A
    0x38, 0x6C, 0xC6, 0xC6, 0xFE, 0xC6, 0xC6, 0x00,
    // 0x42 - B
    0xFC, 0xC6, 0xC6, 0xFC, 0xC6, 0xC6, 0xFC, 0x00,
    // 0x43 - C
    0x7C, 0xC6, 0xC0, 0xC0, 0xC0, 0xC6, 0x7C, 0x00,
    // 0x44 - D
    0xF8, 0xCC, 0xC6, 0xC6, 0xC6, 0xCC, 0xF8, 0x00,
    // 0x45 - E
    0xFE, 0xC0, 0xC0, 0xF8, 0xC0, 0xC0, 0xFE, 0x00,
    // 0x46 - F
    0xFE, 0xC0, 0xC0, 0xF8, 0xC0, 0xC0, 0xC0, 0x00,
    // 0x47 - G
    0x7C, 0xC6, 0xC0, 0xCE, 0xC6, 0xC6, 0x7E, 0x00,
    // 0x48 - H
    0xC6, 0xC6, 0xC6, 0xFE, 0xC6, 0xC6, 0xC6, 0x00,
    // 0x49 - I
    0x7E, 0x18, 0x18, 0x18, 0x18, 0x18, 0x7E, 0x00,
    // 0x4A - J
    0x06, 0x06, 0x06, 0x06, 0xC6, 0xC6, 0x7C, 0x00,
    // 0x4B - K
    0xC6, 0xCC, 0xD8, 0xF0, 0xD8, 0xCC, 0xC6, 0x00,
    // 0x4C - L
    0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xFE, 0x00,
    // 0x4D - M
    0xC6, 0xEE, 0xFE, 0xD6, 0xC6, 0xC6, 0xC6, 0x00,
    // 0x4E - N
    0xC6, 0xE6, 0xF6, 0xDE, 0xCE, 0xC6, 0xC6, 0x00,
    // 0x4F - O
    0x7C, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0x7C, 0x00,
    // 0x50 - P
    0xFC, 0xC6, 0xC6, 0xFC, 0xC0, 0xC0, 0xC0, 0x00,
    // 0x51 - Q
    0x7C, 0xC6, 0xC6, 0xC6, 0xD6, 0xDE, 0x7C, 0x06,
    // 0x52 - R
    0xFC, 0xC6, 0xC6, 0xFC, 0xD8, 0xCC, 0xC6, 0x00,
    // 0x53 - S
    0x7C, 0xC6, 0xC0, 0x7C, 0x06, 0xC6, 0x7C, 0x00,
    // 0x54 - T
    0xFF, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00,
    // 0x55 - U
    0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0x7C, 0x00,
    // 0x56 - V
    0xC6, 0xC6, 0xC6, 0xC6, 0x6C, 0x38, 0x10, 0x00,
    // 0x57 - W
    0xC6, 0xC6, 0xC6, 0xD6, 0xFE, 0xEE, 0xC6, 0x00,
    // 0x58 - X
    0xC6, 0xC6, 0x6C, 0x38, 0x6C, 0xC6, 0xC6, 0x00,
    // 0x59 - Y
    0xC3, 0xC3, 0x66, 0x3C, 0x18, 0x18, 0x18, 0x00,
    // 0x5A - Z
    0xFE, 0x06, 0x0C, 0x18, 0x30, 0x60, 0xFE, 0x00,
    // 0x5B - [
    0x7C, 0x60, 0x60, 0x60, 0x60, 0x60, 0x7C, 0x00,
    // 0x5C - backslash
    0xC0, 0x60, 0x30, 0x18, 0x0C, 0x06, 0x02, 0x00,
    // 0x5D - ]
    0x7C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x7C, 0x00,
    // 0x5E - ^
    0x10, 0x38, 0x6C, 0xC6, 0x00, 0x00, 0x00, 0x00,
    // 0x5F - _
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE,
    // 0x60 - `
    0x30, 0x18, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00,
    // 0x61 - a
    0x00, 0x00, 0x7C, 0x06, 0x7E, 0xC6, 0x7E, 0x00,
    // 0x62 - b
    0xC0, 0xC0, 0xFC, 0xC6, 0xC6, 0xC6, 0xFC, 0x00,
    // 0x63 - c
    0x00, 0x00, 0x7C, 0xC6, 0xC0, 0xC6, 0x7C, 0x00,
    // 0x64 - d
    0x06, 0x06, 0x7E, 0xC6, 0xC6, 0xC6, 0x7E, 0x00,
    // 0x65 - e
    0x00, 0x00, 0x7C, 0xC6, 0xFE, 0xC0, 0x7C, 0x00,
    // 0x66 - f
    0x1C, 0x30, 0x30, 0x7C, 0x30, 0x30, 0x30, 0x00,
    // 0x67 - g
    0x00, 0x00, 0x7E, 0xC6, 0xC6, 0x7E, 0x06, 0x7C,
    // 0x68 - h
    0xC0, 0xC0, 0xFC, 0xC6, 0xC6, 0xC6, 0xC6, 0x00,
    // 0x69 - i
    0x18, 0x00, 0x38, 0x18, 0x18, 0x18, 0x3C, 0x00,
    // 0x6A - j
    0x18, 0x00, 0x38, 0x18, 0x18, 0x18, 0x18, 0x70,
    // 0x6B - k
    0xC0, 0xC0, 0xCC, 0xD8, 0xF0, 0xD8, 0xCC, 0x00,
    // 0x6C - l
    0x38, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00,
    // 0x6D - m
    0x00, 0x00, 0xCC, 0xFE, 0xD6, 0xC6, 0xC6, 0x00,
    // 0x6E - n
    0x00, 0x00, 0xFC, 0xC6, 0xC6, 0xC6, 0xC6, 0x00,
    // 0x6F - o
    0x00, 0x00, 0x7C, 0xC6, 0xC6, 0xC6, 0x7C, 0x00,
    // 0x70 - p
    0x00, 0x00, 0xFC, 0xC6, 0xC6, 0xFC, 0xC0, 0xC0,
    // 0x71 - q
    0x00, 0x00, 0x7E, 0xC6, 0xC6, 0x7E, 0x06, 0x06,
    // 0x72 - r
    0x00, 0x00, 0xDC, 0xE6, 0xC0, 0xC0, 0xC0, 0x00,
    // 0x73 - s
    0x00, 0x00, 0x7E, 0xC0, 0x7C, 0x06, 0xFC, 0x00,
    // 0x74 - t
    0x30, 0x30, 0x7C, 0x30, 0x30, 0x30, 0x1C, 0x00,
    // 0x75 - u
    0x00, 0x00, 0xC6, 0xC6, 0xC6, 0xC6, 0x7E, 0x00,
    // 0x76 - v
    0x00, 0x00, 0xC6, 0xC6, 0xC6, 0x6C, 0x38, 0x00,
    // 0x77 - w
    0x00, 0x00, 0xC6, 0xC6, 0xD6, 0xFE, 0x6C, 0x00,
    // 0x78 - x
    0x00, 0x00, 0xC6, 0x6C, 0x38, 0x6C, 0xC6, 0x00,
    // 0x79 - y
    0x00, 0x00, 0xC6, 0xC6, 0xC6, 0x7E, 0x06, 0x7C,
    // 0x7A - z
    0x00, 0x00, 0xFE, 0x0C, 0x38, 0x60, 0xFE, 0x00,
    // 0x7B - {
    0x0E, 0x18, 0x18, 0x70, 0x18, 0x18, 0x0E, 0x00,
    // 0x7C - |
    0x18, 0x18, 0x18, 0x00, 0x18, 0x18, 0x18, 0x00,
    // 0x7D - }
    0xE0, 0x30, 0x30, 0x1C, 0x30, 0x30, 0xE0, 0x00,
    // 0x7E - ~
    0x76, 0xDC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    // 0x7F - DEL (house)
    0x10, 0x38, 0x6C, 0xC6, 0xC6, 0xFE, 0x00, 0x00,
    // 0x80-0xFF: Extended ASCII (box drawing, etc.)
    // 0x80 - Ç
    0x7C, 0xC6, 0xC0, 0xC0, 0xC6, 0x7C, 0x0C, 0x78,
    // 0x81 - ü
    0x6C, 0x00, 0xC6, 0xC6, 0xC6, 0xC6, 0x7E, 0x00,
    // 0x82 - é
    0x0C, 0x18, 0x7C, 0xC6, 0xFE, 0xC0, 0x7C, 0x00,
    // 0x83 - â
    0x38, 0x6C, 0x7C, 0x06, 0x7E, 0xC6, 0x7E, 0x00,
    // 0x84 - ä
    0x6C, 0x00, 0x7C, 0x06, 0x7E, 0xC6, 0x7E, 0x00,
    // 0x85 - à
    0x60, 0x30, 0x7C, 0x06, 0x7E, 0xC6, 0x7E, 0x00,
    // 0x86 - å
    0x38, 0x6C, 0x38, 0x7C, 0x06, 0x7E, 0x7E, 0x00,
    // 0x87 - ç
    0x00, 0x00, 0x7C, 0xC0, 0xC0, 0x7C, 0x0C, 0x78,
    // 0x88 - ê
    0x38, 0x6C, 0x7C, 0xC6, 0xFE, 0xC0, 0x7C, 0x00,
    // 0x89 - ë
    0x6C, 0x00, 0x7C, 0xC6, 0xFE, 0xC0, 0x7C, 0x00,
    // 0x8A - è
    0x60, 0x30, 0x7C, 0xC6, 0xFE, 0xC0, 0x7C, 0x00,
    // 0x8B - ï
    0x6C, 0x00, 0x38, 0x18, 0x18, 0x18, 0x3C, 0x00,
    // 0x8C - î
    0x38, 0x6C, 0x00, 0x38, 0x18, 0x18, 0x3C, 0x00,
    // 0x8D - ì
    0x60, 0x30, 0x00, 0x38, 0x18, 0x18, 0x3C, 0x00,
    // 0x8E - Ä
    0x6C, 0x38, 0x6C, 0xC6, 0xFE, 0xC6, 0xC6, 0x00,
    // 0x8F - Å
    0x38, 0x6C, 0x38, 0x6C, 0xC6, 0xFE, 0xC6, 0x00,
    // 0x90 - É
    0x0C, 0x18, 0xFE, 0xC0, 0xF8, 0xC0, 0xFE, 0x00,
    // 0x91 - æ
    0x00, 0x00, 0x6C, 0x3E, 0x7C, 0xCC, 0x7E, 0x00,
    // 0x92 - Æ
    0x3E, 0x6C, 0xCC, 0xFE, 0xCC, 0xCC, 0xCE, 0x00,
    // 0x93 - ô
    0x38, 0x6C, 0x00, 0x7C, 0xC6, 0xC6, 0x7C, 0x00,
    // 0x94 - ö
    0x6C, 0x00, 0x7C, 0xC6, 0xC6, 0xC6, 0x7C, 0x00,
    // 0x95 - ò
    0x60, 0x30, 0x7C, 0xC6, 0xC6, 0xC6, 0x7C, 0x00,
    // 0x96 - û
    0x38, 0x6C, 0x00, 0xC6, 0xC6, 0xC6, 0x7E, 0x00,
    // 0x97 - ù
    0x60, 0x30, 0x00, 0xC6, 0xC6, 0xC6, 0x7E, 0x00,
    // 0x98 - ÿ
    0x6C, 0x00, 0xC6, 0xC6, 0xC6, 0x7E, 0x06, 0x7C,
    // 0x99 - Ö
    0x6C, 0x7C, 0xC6, 0xC6, 0xC6, 0xC6, 0x7C, 0x00,
    // 0x9A - Ü
    0x6C, 0x00, 0xC6, 0xC6, 0xC6, 0xC6, 0x7C, 0x00,
    // 0x9B - ¢
    0x18, 0x7E, 0xD8, 0xD8, 0xD8, 0x7E, 0x18, 0x00,
    // 0x9C - £
    0x38, 0x6C, 0x60, 0xF0, 0x60, 0x66, 0xFC, 0x00,
    // 0x9D - ¥
    0xC3, 0x66, 0x3C, 0x18, 0x3C, 0x18, 0x18, 0x00,
    // 0x9E - ₧
    0xF8, 0xCC, 0xCC, 0xFA, 0xC6, 0xCF, 0xC6, 0xC7,
    // 0x9F - ƒ
    0x0E, 0x1B, 0x18, 0x3C, 0x18, 0x18, 0xD8, 0x70,
    // 0xA0 - á
    0x0C, 0x18, 0x7C, 0x06, 0x7E, 0xC6, 0x7E, 0x00,
    // 0xA1 - í
    0x0C, 0x18, 0x00, 0x38, 0x18, 0x18, 0x3C, 0x00,
    // 0xA2 - ó
    0x0C, 0x18, 0x7C, 0xC6, 0xC6, 0xC6, 0x7C, 0x00,
    // 0xA3 - ú
    0x0C, 0x18, 0x00, 0xC6, 0xC6, 0xC6, 0x7E, 0x00,
    // 0xA4 - ñ
    0x76, 0xDC, 0x00, 0xFC, 0xC6, 0xC6, 0xC6, 0x00,
    // 0xA5 - Ñ
    0x76, 0xDC, 0xC6, 0xE6, 0xF6, 0xDE, 0xCE, 0x00,
    // 0xA6 - ª
    0x3C, 0x6C, 0x6C, 0x3E, 0x00, 0x7E, 0x00, 0x00,
    // 0xA7 - º
    0x3C, 0x66, 0x66, 0x3C, 0x00, 0x7E, 0x00, 0x00,
    // 0xA8 - ¿
    0x18, 0x00, 0x18, 0x30, 0x60, 0xC6, 0x7C, 0x00,
    // 0xA9 - ⌐
    0x00, 0x00, 0x00, 0xFC, 0xC0, 0xC0, 0x00, 0x00,
    // 0xAA - ¬
    0x00, 0x00, 0x00, 0xFC, 0x0C, 0x0C, 0x00, 0x00,
    // 0xAB - ½
    0xC0, 0xC8, 0xD0, 0xFE, 0x46, 0x8C, 0x1E, 0x00,
    // 0xAC - ¼
    0xC0, 0xC8, 0xD0, 0xEC, 0x5C, 0xBE, 0x0C, 0x00,
    // 0xAD - ¡
    0x18, 0x00, 0x18, 0x18, 0x3C, 0x3C, 0x18, 0x00,
    // 0xAE - «
    0x00, 0x36, 0x6C, 0xD8, 0x6C, 0x36, 0x00, 0x00,
    // 0xAF - »
    0x00, 0xD8, 0x6C, 0x36, 0x6C, 0xD8, 0x00, 0x00,
    // 0xB0 - ░ (light shade)
    0x22, 0x88, 0x22, 0x88, 0x22, 0x88, 0x22, 0x88,
    // 0xB1 - ▒ (medium shade)
    0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA,
    // 0xB2 - ▓ (dark shade)
    0xDD, 0x77, 0xDD, 0x77, 0xDD, 0x77, 0xDD, 0x77,
    // 0xB3 - │ (vertical line)
    0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
    // 0xB4 - ┤
    0x18, 0x18, 0x18, 0xF8, 0x18, 0x18, 0x18, 0x18,
    // 0xB5 - ╡
    0x18, 0x18, 0xF8, 0x18, 0xF8, 0x18, 0x18, 0x18,
    // 0xB6 - ╢
    0x36, 0x36, 0x36, 0xF6, 0x36, 0x36, 0x36, 0x36,
    // 0xB7 - ╖
    0x00, 0x00, 0x00, 0xFE, 0x36, 0x36, 0x36, 0x36,
    // 0xB8 - ╕
    0x00, 0x00, 0xF8, 0x18, 0xF8, 0x18, 0x18, 0x18,
    // 0xB9 - ╣
    0x36, 0x36, 0xF6, 0x06, 0xF6, 0x36, 0x36, 0x36,
    // 0xBA - ║ (double vertical)
    0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
    // 0xBB - ╗
    0x00, 0x00, 0xFE, 0x06, 0xF6, 0x36, 0x36, 0x36,
    // 0xBC - ╝
    0x36, 0x36, 0xF6, 0x06, 0xFE, 0x00, 0x00, 0x00,
    // 0xBD - ╜
    0x36, 0x36, 0x36, 0xFE, 0x00, 0x00, 0x00, 0x00,
    // 0xBE - ╛
    0x18, 0x18, 0xF8, 0x18, 0xF8, 0x00, 0x00, 0x00,
    // 0xBF - ┐
    0x00, 0x00, 0x00, 0xF8, 0x18, 0x18, 0x18, 0x18,
    // 0xC0 - └
    0x18, 0x18, 0x18, 0x1F, 0x00, 0x00, 0x00, 0x00,
    // 0xC1 - ┴
    0x18, 0x18, 0x18, 0xFF, 0x00, 0x00, 0x00, 0x00,
    // 0xC2 - ┬
    0x00, 0x00, 0x00, 0xFF, 0x18, 0x18, 0x18, 0x18,
    // 0xC3 - ├
    0x18, 0x18, 0x18, 0x1F, 0x18, 0x18, 0x18, 0x18,
    // 0xC4 - ─ (horizontal line)
    0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00,
    // 0xC5 - ┼
    0x18, 0x18, 0x18, 0xFF, 0x18, 0x18, 0x18, 0x18,
    // 0xC6 - ╞
    0x18, 0x18, 0x1F, 0x18, 0x1F, 0x18, 0x18, 0x18,
    // 0xC7 - ╟
    0x36, 0x36, 0x36, 0x37, 0x36, 0x36, 0x36, 0x36,
    // 0xC8 - ╚
    0x36, 0x36, 0x37, 0x30, 0x3F, 0x00, 0x00, 0x00,
    // 0xC9 - ╔
    0x00, 0x00, 0x3F, 0x30, 0x37, 0x36, 0x36, 0x36,
    // 0xCA - ╩
    0x36, 0x36, 0xF7, 0x00, 0xFF, 0x00, 0x00, 0x00,
    // 0xCB - ╦
    0x00, 0x00, 0xFF, 0x00, 0xF7, 0x36, 0x36, 0x36,
    // 0xCC - ╠
    0x36, 0x36, 0x37, 0x30, 0x37, 0x36, 0x36, 0x36,
    // 0xCD - ═ (double horizontal)
    0x00, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0x00, 0x00,
    // 0xCE - ╬
    0x36, 0x36, 0xF7, 0x00, 0xF7, 0x36, 0x36, 0x36,
    // 0xCF - ╧
    0x18, 0x18, 0xFF, 0x00, 0xFF, 0x00, 0x00, 0x00,
    // 0xD0 - ╨
    0x36, 0x36, 0x36, 0xFF, 0x00, 0x00, 0x00, 0x00,
    // 0xD1 - ╤
    0x00, 0x00, 0xFF, 0x00, 0xFF, 0x18, 0x18, 0x18,
    // 0xD2 - ╥
    0x00, 0x00, 0x00, 0xFF, 0x36, 0x36, 0x36, 0x36,
    // 0xD3 - ╙
    0x36, 0x36, 0x36, 0x3F, 0x00, 0x00, 0x00, 0x00,
    // 0xD4 - ╘
    0x18, 0x18, 0x1F, 0x18, 0x1F, 0x00, 0x00, 0x00,
    // 0xD5 - ╒
    0x00, 0x00, 0x1F, 0x18, 0x1F, 0x18, 0x18, 0x18,
    // 0xD6 - ╓
    0x00, 0x00, 0x00, 0x3F, 0x36, 0x36, 0x36, 0x36,
    // 0xD7 - ╫
    0x36, 0x36, 0x36, 0xF7, 0x36, 0x36, 0x36, 0x36,
    // 0xD8 - ╪
    0x18, 0x18, 0xFF, 0x18, 0xFF, 0x18, 0x18, 0x18,
    // 0xD9 - ┘
    0x18, 0x18, 0x18, 0xF8, 0x00, 0x00, 0x00, 0x00,
    // 0xDA - ┌
    0x00, 0x00, 0x00, 0x1F, 0x18, 0x18, 0x18, 0x18,
    // 0xDB - █ (full block)
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    // 0xDC - ▄ (lower half)
    0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF,
    // 0xDD - ▌ (left half)
    0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0,
    // 0xDE - ▐ (right half)
    0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F,
    // 0xDF - ▀ (upper half)
    0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00,
    // 0xE0 - α
    0x00, 0x00, 0x76, 0xDC, 0xC8, 0xDC, 0x76, 0x00,
    // 0xE1 - ß
    0x78, 0xCC, 0xCC, 0xD8, 0xCC, 0xC6, 0xCC, 0x00,
    // 0xE2 - Γ
    0xFE, 0xC6, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0x00,
    // 0xE3 - π
    0x00, 0x00, 0xFE, 0x6C, 0x6C, 0x6C, 0x6C, 0x00,
    // 0xE4 - Σ
    0xFE, 0xC6, 0x60, 0x30, 0x60, 0xC6, 0xFE, 0x00,
    // 0xE5 - σ
    0x00, 0x00, 0x7E, 0xD8, 0xD8, 0xD8, 0x70, 0x00,
    // 0xE6 - µ
    0x00, 0x00, 0x66, 0x66, 0x66, 0x66, 0x7C, 0xC0,
    // 0xE7 - τ
    0x00, 0x00, 0x76, 0xDC, 0x18, 0x18, 0x18, 0x00,
    // 0xE8 - Φ
    0x7E, 0x18, 0x3C, 0x66, 0x66, 0x3C, 0x18, 0x7E,
    // 0xE9 - Θ
    0x38, 0x6C, 0xC6, 0xFE, 0xC6, 0x6C, 0x38, 0x00,
    // 0xEA - Ω
    0x38, 0x6C, 0xC6, 0xC6, 0x6C, 0x6C, 0xEE, 0x00,
    // 0xEB - δ
    0x0E, 0x18, 0x0C, 0x3E, 0x66, 0x66, 0x3C, 0x00,
    // 0xEC - ∞
    0x00, 0x00, 0x7E, 0xDB, 0xDB, 0x7E, 0x00, 0x00,
    // 0xED - φ
    0x06, 0x0C, 0x7E, 0xDB, 0xDB, 0x7E, 0x60, 0xC0,
    // 0xEE - ε
    0x1E, 0x30, 0x60, 0x7E, 0x60, 0x30, 0x1E, 0x00,
    // 0xEF - ∩
    0x00, 0x7C, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0x00,
    // 0xF0 - ≡
    0x00, 0xFE, 0x00, 0xFE, 0x00, 0xFE, 0x00, 0x00,
    // 0xF1 - ±
    0x18, 0x18, 0x7E, 0x18, 0x18, 0x00, 0x7E, 0x00,
    // 0xF2 - ≥
    0x30, 0x18, 0x0C, 0x18, 0x30, 0x00, 0x7E, 0x00,
    // 0xF3 - ≤
    0x0C, 0x18, 0x30, 0x18, 0x0C, 0x00, 0x7E, 0x00,
    // 0xF4 - ⌠
    0x0E, 0x1B, 0x1B, 0x18, 0x18, 0x18, 0x18, 0x18,
    // 0xF5 - ⌡
    0x18, 0x18, 0x18, 0x18, 0x18, 0xD8, 0xD8, 0x70,
    // 0xF6 - ÷
    0x00, 0x18, 0x00, 0x7E, 0x00, 0x18, 0x00, 0x00,
    // 0xF7 - ≈
    0x00, 0x76, 0xDC, 0x00, 0x76, 0xDC, 0x00, 0x00,
    // 0xF8 - °
    0x38, 0x6C, 0x6C, 0x38, 0x00, 0x00, 0x00, 0x00,
    // 0xF9 - ∙
    0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00,
    // 0xFA - ·
    0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00,
    // 0xFB - √
    0x0F, 0x0C, 0x0C, 0x0C, 0xEC, 0x6C, 0x3C, 0x1C,
    // 0xFC - ⁿ
    0x6C, 0x36, 0x36, 0x36, 0x36, 0x00, 0x00, 0x00,
    // 0xFD - ²
    0x78, 0x0C, 0x18, 0x30, 0x7C, 0x00, 0x00, 0x00,
    // 0xFE - ■ (filled square)
    0x00, 0x00, 0x3C, 0x3C, 0x3C, 0x3C, 0x00, 0x00,
    // 0xFF - nbsp
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
];

// ============================================================================
// Character Index Mapping
// ============================================================================

/// Down arrow character (special case - use this instead of 'v' for arrow)
pub const DOWN_ARROW: u8 = 0x19; // Using a control char that won't conflict

/// Map an ASCII character to its font index
///
/// # Arguments
/// * `ch` - ASCII character byte
///
/// # Returns
/// Font index
#[inline(never)]
pub fn char_to_index(ch: u8) -> usize {
    ch as usize
}

/// Get the bitmap data for a character as a fixed-size array (by value)
///
/// # Arguments
/// * `ch` - ASCII character byte
///
/// # Returns
/// Array of 8 bytes representing the character bitmap (copied by value)
#[inline(never)]
pub fn get_char_bitmap(ch: u8) -> [u8; 8] {
    let index = char_to_index(ch);
    let start = (ch as usize) * 8;
    // Copy the 8 bytes into a fixed-size array
    [
        FONT_DATA[start],
        FONT_DATA[start + 1],
        FONT_DATA[start + 2],
        FONT_DATA[start + 3],
        FONT_DATA[start + 4],
        FONT_DATA[start + 5],
        FONT_DATA[start + 6],
        FONT_DATA[start + 7],
    ]
}

// ============================================================================
// Buffer-Based Rendering (for mode13h.rs and offscreen buffers)
// ============================================================================

/// Draw a character bitmap to a buffer
#[inline]
fn draw_bitmap_to_buffer(
    buffer: &mut [u8],
    x: usize,
    y: usize,
    bitmap: [u8; 8],
    color: u8,
) {
    for (row, bits) in bitmap.iter().enumerate().take(CHAR_HEIGHT) {
        let py = y + row;
        for col in 0..CHAR_WIDTH {
            if (bits >> (7 - col)) & 1 != 0 {
                let px = x + col;
                let offset = py * SCREEN_WIDTH + px;
                if offset < buffer.len() {
                    buffer[offset] = color;
                }
            }
        }
    }
}

/// Draw a character bitmap to a buffer with background color
#[inline]
fn draw_bitmap_to_buffer_bg(
    buffer: &mut [u8],
    x: usize,
    y: usize,
    bitmap: [u8; 8],
    fg: u8,
    bg: u8,
) {
    for (row, bits) in bitmap.iter().enumerate().take(CHAR_HEIGHT) {
        let py = y + row;
        for col in 0..CHAR_WIDTH {
            let px = x + col;
            let offset = py * SCREEN_WIDTH + px;
            if offset < buffer.len() {
                buffer[offset] = if (bits >> (7 - col)) & 1 != 0 { fg } else { bg };
            }
        }
    }
}

/// Draw a single character to a buffer (foreground only)
///
/// This is the primary buffer-based draw_char used by mode13h.rs
pub fn draw_char(buffer: &mut [u8], x: usize, y: usize, ch: u8, fg: u8) {
    let bitmap = get_char_bitmap(ch);
    draw_bitmap_to_buffer(buffer, x, y, bitmap, fg);
}

/// Draw a single character to a buffer with background color
pub fn draw_char_bg(buffer: &mut [u8], x: usize, y: usize, ch: u8, fg: u8, bg: u8) {
    let bitmap = get_char_bitmap(ch);
    draw_bitmap_to_buffer_bg(buffer, x, y, bitmap, fg, bg);
}

/// Draw a string to a buffer (foreground only)
pub fn draw_str(buffer: &mut [u8], x: usize, y: usize, s: &str, fg: u8) {
    let mut cx = x;
    for ch in s.bytes() {
        draw_char(buffer, cx, y, ch, fg);
        cx += CHAR_WIDTH;
    }
}

/// Draw a &str string to a buffer (foreground only) - alias for draw_str
pub fn draw_string(buffer: &mut [u8], x: usize, y: usize, s: &str, fg: u8) {
    draw_str(buffer, x, y, s, fg);
}

/// Draw a string to a buffer with background color
pub fn draw_str_bg(buffer: &mut [u8], x: usize, y: usize, s: &str, fg: u8, bg: u8) {
    let mut cx = x;
    for ch in s.bytes() {
        draw_char_bg(buffer, cx, y, ch, fg, bg);
        cx += CHAR_WIDTH;
    }
}

/// Draw a string centered horizontally to a buffer
pub fn draw_string_centered(buffer: &mut [u8], y: usize, s: &str, fg: u8) {
    let width = s.len() * CHAR_WIDTH;
    let x = (SCREEN_WIDTH.saturating_sub(width)) / 2;
    draw_str(buffer, x, y, s, fg);
}

/// Draw an unsigned number to a buffer
pub fn draw_number(buffer: &mut [u8], x: usize, y: usize, n: u32, min_width: usize, fg: u8) {
    let mut digits = [0u8; 10];
    let mut num = n;
    let mut count = 0;

    // Extract digits (reverse order)
    loop {
        digits[count] = b'0' + (num % 10) as u8;
        count += 1;
        num /= 10;
        if num == 0 {
            break;
        }
    }

    // Pad with spaces if needed
    let mut cx = x;
    if count < min_width {
        for _ in 0..(min_width - count) {
            draw_char(buffer, cx, y, b' ', fg);
            cx += CHAR_WIDTH;
        }
    }

    // Draw digits in correct order
    for i in (0..count).rev() {
        draw_char(buffer, cx, y, digits[i], fg);
        cx += CHAR_WIDTH;
    }
}

/// Draw a signed number to a buffer
pub fn draw_signed(buffer: &mut [u8], x: usize, y: usize, n: i32, min_width: usize, fg: u8) {
    let mut cx = x;
    if n < 0 {
        draw_char(buffer, cx, y, b'-', fg);
        cx += CHAR_WIDTH;
        draw_number(buffer, cx, y, (-n) as u32, min_width.saturating_sub(1), fg);
    } else {
        draw_number(buffer, cx, y, n as u32, min_width, fg);
    }
}

/// Draw a hexadecimal number to a buffer
pub fn draw_hex(buffer: &mut [u8], x: usize, y: usize, n: u32, digits: usize, fg: u8) {
    const HEX_CHARS: &[u8] = b"0123456789ABCDEF";
    let mut cx = x;
    for i in (0..digits).rev() {
        let nibble = ((n >> (i * 4)) & 0xF) as usize;
        draw_char(buffer, cx, y, HEX_CHARS[nibble], fg);
        cx += CHAR_WIDTH;
    }
}

/// Calculate the pixel width of a string
#[inline]
pub fn string_width(s: &str) -> usize {
    s.len() * CHAR_WIDTH
}

// ============================================================================
// VGA-Direct Rendering (for rom_browser.rs - writes directly to VGA memory)
// ============================================================================

/// Draw a single character directly to VGA memory
#[inline(never)]
pub fn draw_char_vga(x: usize, y: usize, ch: u8, color: u8) {
    let bitmap = get_char_bitmap(ch);
    vga_mode13h::draw_bitmap_8x8(x, y, bitmap, color);
}

/// Draw a string directly to VGA memory
#[inline(never)]
pub fn draw_string_vga(x: usize, y: usize, s: &str, color: u8) {
    let mut cx = x;
    for ch in s.bytes() {
        draw_char_vga(cx, y, ch, color);
        cx += CHAR_WIDTH;
    }
}

/// Draw a string centered horizontally, directly to VGA memory
#[inline(never)]
pub fn draw_string_centered_vga(y: usize, s: &str, color: u8) {
    let width = s.len() * CHAR_WIDTH;
    let x = (SCREEN_WIDTH.saturating_sub(width)) / 2;
    draw_string_vga(x, y, s, color);
}
