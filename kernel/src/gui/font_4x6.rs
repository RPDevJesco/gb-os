//! 4x6 Compact Bitmap Font
//!
//! A space-efficient monospace bitmap font for VGA text rendering.
//! Each character is 4x6 pixels, stored as 6 bytes (one per row).
//! MSB is the leftmost pixel in each row (top 4 bits used).
//!
//! Designed for overlay rendering where the 8x8 font is too large.

use crate::graphics::vga_mode13h::{self, SCREEN_WIDTH};

// Re-export colors for compatibility with existing code
pub use crate::graphics::vga_mode13h::colors;

// ============================================================================
// Font Data
// ============================================================================

/// Number of characters in the font (full ASCII 0-255)
pub const CHAR_COUNT: usize = 256;

/// Character width in pixels
pub const CHAR_WIDTH: usize = 4;

/// Character height in pixels
pub const CHAR_HEIGHT: usize = 6;

/// Recommended spacing between characters
pub const CHAR_SPACING: usize = 1;

/// Effective cell width (character + spacing)
pub const CELL_WIDTH: usize = CHAR_WIDTH + CHAR_SPACING; // 5

/// Effective cell height (character + spacing)  
pub const CELL_HEIGHT: usize = CHAR_HEIGHT + CHAR_SPACING; // 7

/// 4x6 bitmap font data
///
/// Each character is 6 bytes (one per row).
/// Pixel data is in the top 4 bits of each byte, MSB = leftmost pixel.
/// Covers full ASCII 0-255 (256 characters).
///
/// Total size: 256 characters × 6 bytes = 1536 bytes
#[rustfmt::skip]
static FONT_DATA: [u8; CHAR_COUNT * CHAR_HEIGHT] = [
    // 0x00 - Null (empty)
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    // 0x01 - SOH (smiley face)
    0x60, 0x90, 0x60, 0x90, 0x60, 0x00,
    // 0x02 - STX (filled smiley)
    0x60, 0xF0, 0x60, 0xF0, 0x60, 0x00,
    // 0x03 - ETX (heart)
    0x50, 0xF0, 0xF0, 0x60, 0x20, 0x00,
    // 0x04 - EOT (diamond)
    0x20, 0x70, 0xF0, 0x70, 0x20, 0x00,
    // 0x05 - ENQ (club)
    0x40, 0xE0, 0x40, 0xE0, 0x40, 0x00,
    // 0x06 - ACK (spade)
    0x20, 0x70, 0xF0, 0x70, 0x20, 0x70,
    // 0x07 - BEL (bullet)
    0x00, 0x60, 0x60, 0x00, 0x00, 0x00,
    // 0x08 - BS (inverse bullet)
    0xF0, 0x90, 0x90, 0xF0, 0xF0, 0xF0,
    // 0x09 - HT (circle)
    0x60, 0x90, 0x90, 0x60, 0x00, 0x00,
    // 0x0A - LF (inverse circle)
    0x90, 0x60, 0x60, 0x90, 0xF0, 0xF0,
    // 0x0B - VT (male symbol)
    0x30, 0x70, 0xA0, 0xA0, 0x40, 0x00,
    // 0x0C - FF (female symbol)
    0x60, 0x90, 0x60, 0x40, 0xE0, 0x40,
    // 0x0D - CR (note)
    0x70, 0x50, 0x70, 0x40, 0xC0, 0x00,
    // 0x0E - SO (sun)
    0x70, 0x50, 0x70, 0x50, 0xD0, 0x80,
    // 0x0F - SI (star)
    0x90, 0x60, 0xF0, 0x60, 0x90, 0x00,
    // 0x10 - DLE (right triangle)
    0x80, 0xC0, 0xE0, 0xC0, 0x80, 0x00,
    // 0x11 - DC1 (left triangle)
    0x10, 0x30, 0x70, 0x30, 0x10, 0x00,
    // 0x12 - DC2 (up-down arrow)
    0x40, 0xE0, 0x40, 0xE0, 0x40, 0x00,
    // 0x13 - DC3 (double exclamation)
    0xA0, 0xA0, 0xA0, 0x00, 0xA0, 0x00,
    // 0x14 - DC4 (paragraph)
    0x70, 0xD0, 0x50, 0x50, 0x50, 0x00,
    // 0x15 - NAK (section)
    0x70, 0x80, 0x60, 0x90, 0x60, 0x10,
    // 0x16 - SYN (thick underline)
    0x00, 0x00, 0x00, 0xF0, 0xF0, 0x00,
    // 0x17 - ETB (up-down arrow with base)
    0x40, 0xE0, 0x40, 0xE0, 0x40, 0xF0,
    // 0x18 - CAN (up arrow)
    0x40, 0xE0, 0x40, 0x40, 0x40, 0x00,
    // 0x19 - EM (down arrow)
    0x40, 0x40, 0x40, 0xE0, 0x40, 0x00,
    // 0x1A - SUB (right arrow)
    0x00, 0x40, 0xF0, 0x40, 0x00, 0x00,
    // 0x1B - ESC (left arrow)
    0x00, 0x40, 0xF0, 0x40, 0x00, 0x00,
    // 0x1C - FS (right angle)
    0x00, 0x80, 0x80, 0xF0, 0x00, 0x00,
    // 0x1D - GS (left-right arrow)
    0x00, 0xA0, 0xF0, 0xA0, 0x00, 0x00,
    // 0x1E - RS (up triangle)
    0x20, 0x70, 0xF0, 0x00, 0x00, 0x00,
    // 0x1F - US (down triangle)
    0x00, 0x00, 0xF0, 0x70, 0x20, 0x00,
    // 0x20 - Space
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    // 0x21 - !
    0x40, 0x40, 0x40, 0x40, 0x00, 0x40,
    // 0x22 - "
    0xA0, 0xA0, 0x00, 0x00, 0x00, 0x00,
    // 0x23 - #
    0x50, 0xF0, 0x50, 0xF0, 0x50, 0x00,
    // 0x24 - $
    0x40, 0x70, 0xC0, 0x30, 0xE0, 0x40,
    // 0x25 - %
    0x90, 0x20, 0x40, 0x80, 0x90, 0x00,
    // 0x26 - &
    0x40, 0xA0, 0x40, 0xA0, 0x50, 0x00,
    // 0x27 - '
    0x40, 0x40, 0x00, 0x00, 0x00, 0x00,
    // 0x28 - (
    0x20, 0x40, 0x40, 0x40, 0x20, 0x00,
    // 0x29 - )
    0x40, 0x20, 0x20, 0x20, 0x40, 0x00,
    // 0x2A - *
    0x00, 0xA0, 0x40, 0xA0, 0x00, 0x00,
    // 0x2B - +
    0x00, 0x40, 0xE0, 0x40, 0x00, 0x00,
    // 0x2C - ,
    0x00, 0x00, 0x00, 0x40, 0x40, 0x80,
    // 0x2D - -
    0x00, 0x00, 0xE0, 0x00, 0x00, 0x00,
    // 0x2E - .
    0x00, 0x00, 0x00, 0x00, 0x40, 0x00,
    // 0x2F - /
    0x10, 0x20, 0x40, 0x40, 0x80, 0x00,
    // 0x30 - 0
    0x60, 0x90, 0xB0, 0xD0, 0x90, 0x60,
    // 0x31 - 1
    0x20, 0x60, 0x20, 0x20, 0x20, 0x70,
    // 0x32 - 2
    0x60, 0x90, 0x20, 0x40, 0x80, 0xF0,
    // 0x33 - 3
    0xE0, 0x10, 0x60, 0x10, 0x10, 0xE0,
    // 0x34 - 4
    0x20, 0x60, 0xA0, 0xF0, 0x20, 0x20,
    // 0x35 - 5
    0xF0, 0x80, 0xE0, 0x10, 0x10, 0xE0,
    // 0x36 - 6
    0x60, 0x80, 0xE0, 0x90, 0x90, 0x60,
    // 0x37 - 7
    0xF0, 0x10, 0x20, 0x40, 0x40, 0x40,
    // 0x38 - 8
    0x60, 0x90, 0x60, 0x90, 0x90, 0x60,
    // 0x39 - 9
    0x60, 0x90, 0x90, 0x70, 0x10, 0x60,
    // 0x3A - :
    0x00, 0x40, 0x00, 0x00, 0x40, 0x00,
    // 0x3B - ;
    0x00, 0x40, 0x00, 0x40, 0x40, 0x80,
    // 0x3C - <
    0x10, 0x20, 0x40, 0x20, 0x10, 0x00,
    // 0x3D - =
    0x00, 0xF0, 0x00, 0xF0, 0x00, 0x00,
    // 0x3E - >
    0x80, 0x40, 0x20, 0x40, 0x80, 0x00,
    // 0x3F - ?
    0x60, 0x90, 0x20, 0x40, 0x00, 0x40,
    // 0x40 - @
    0x60, 0x90, 0xB0, 0xB0, 0x80, 0x70,
    // 0x41 - A
    0x60, 0x90, 0x90, 0xF0, 0x90, 0x90,
    // 0x42 - B
    0xE0, 0x90, 0xE0, 0x90, 0x90, 0xE0,
    // 0x43 - C
    0x60, 0x90, 0x80, 0x80, 0x90, 0x60,
    // 0x44 - D
    0xE0, 0x90, 0x90, 0x90, 0x90, 0xE0,
    // 0x45 - E
    0xF0, 0x80, 0xE0, 0x80, 0x80, 0xF0,
    // 0x46 - F
    0xF0, 0x80, 0xE0, 0x80, 0x80, 0x80,
    // 0x47 - G
    0x60, 0x90, 0x80, 0xB0, 0x90, 0x60,
    // 0x48 - H
    0x90, 0x90, 0xF0, 0x90, 0x90, 0x90,
    // 0x49 - I
    0xE0, 0x40, 0x40, 0x40, 0x40, 0xE0,
    // 0x4A - J
    0x70, 0x20, 0x20, 0x20, 0xA0, 0x40,
    // 0x4B - K
    0x90, 0xA0, 0xC0, 0xC0, 0xA0, 0x90,
    // 0x4C - L
    0x80, 0x80, 0x80, 0x80, 0x80, 0xF0,
    // 0x4D - M
    0x90, 0xF0, 0xF0, 0x90, 0x90, 0x90,
    // 0x4E - N
    0x90, 0xD0, 0xF0, 0xB0, 0x90, 0x90,
    // 0x4F - O
    0x60, 0x90, 0x90, 0x90, 0x90, 0x60,
    // 0x50 - P
    0xE0, 0x90, 0x90, 0xE0, 0x80, 0x80,
    // 0x51 - Q
    0x60, 0x90, 0x90, 0xB0, 0xD0, 0x60,
    // 0x52 - R
    0xE0, 0x90, 0x90, 0xE0, 0xA0, 0x90,
    // 0x53 - S
    0x70, 0x80, 0x60, 0x10, 0x10, 0xE0,
    // 0x54 - T
    0xE0, 0x40, 0x40, 0x40, 0x40, 0x40,
    // 0x55 - U
    0x90, 0x90, 0x90, 0x90, 0x90, 0x60,
    // 0x56 - V
    0x90, 0x90, 0x90, 0x90, 0x60, 0x20,
    // 0x57 - W
    0x90, 0x90, 0x90, 0xF0, 0xF0, 0x90,
    // 0x58 - X
    0x90, 0x90, 0x60, 0x60, 0x90, 0x90,
    // 0x59 - Y
    0xA0, 0xA0, 0x40, 0x40, 0x40, 0x40,
    // 0x5A - Z
    0xF0, 0x10, 0x20, 0x40, 0x80, 0xF0,
    // 0x5B - [
    0x60, 0x40, 0x40, 0x40, 0x40, 0x60,
    // 0x5C - backslash
    0x80, 0x40, 0x40, 0x20, 0x20, 0x10,
    // 0x5D - ]
    0x60, 0x20, 0x20, 0x20, 0x20, 0x60,
    // 0x5E - ^
    0x40, 0xA0, 0x00, 0x00, 0x00, 0x00,
    // 0x5F - _
    0x00, 0x00, 0x00, 0x00, 0x00, 0xF0,
    // 0x60 - `
    0x40, 0x20, 0x00, 0x00, 0x00, 0x00,
    // 0x61 - a
    0x00, 0x60, 0x10, 0x70, 0x90, 0x70,
    // 0x62 - b
    0x80, 0x80, 0xE0, 0x90, 0x90, 0xE0,
    // 0x63 - c
    0x00, 0x70, 0x80, 0x80, 0x80, 0x70,
    // 0x64 - d
    0x10, 0x10, 0x70, 0x90, 0x90, 0x70,
    // 0x65 - e
    0x00, 0x60, 0x90, 0xF0, 0x80, 0x70,
    // 0x66 - f
    0x20, 0x40, 0xE0, 0x40, 0x40, 0x40,
    // 0x67 - g
    0x00, 0x70, 0x90, 0x70, 0x10, 0x60,
    // 0x68 - h
    0x80, 0x80, 0xE0, 0x90, 0x90, 0x90,
    // 0x69 - i
    0x40, 0x00, 0xC0, 0x40, 0x40, 0xE0,
    // 0x6A - j
    0x20, 0x00, 0x60, 0x20, 0x20, 0xC0,
    // 0x6B - k
    0x80, 0x90, 0xA0, 0xC0, 0xA0, 0x90,
    // 0x6C - l
    0xC0, 0x40, 0x40, 0x40, 0x40, 0xE0,
    // 0x6D - m
    0x00, 0xA0, 0xF0, 0xF0, 0x90, 0x90,
    // 0x6E - n
    0x00, 0xE0, 0x90, 0x90, 0x90, 0x90,
    // 0x6F - o
    0x00, 0x60, 0x90, 0x90, 0x90, 0x60,
    // 0x70 - p
    0x00, 0xE0, 0x90, 0xE0, 0x80, 0x80,
    // 0x71 - q
    0x00, 0x70, 0x90, 0x70, 0x10, 0x10,
    // 0x72 - r
    0x00, 0xA0, 0xD0, 0x80, 0x80, 0x80,
    // 0x73 - s
    0x00, 0x70, 0xC0, 0x30, 0x10, 0xE0,
    // 0x74 - t
    0x40, 0xE0, 0x40, 0x40, 0x40, 0x20,
    // 0x75 - u
    0x00, 0x90, 0x90, 0x90, 0x90, 0x70,
    // 0x76 - v
    0x00, 0x90, 0x90, 0x90, 0x60, 0x20,
    // 0x77 - w
    0x00, 0x90, 0x90, 0xF0, 0xF0, 0x90,
    // 0x78 - x
    0x00, 0x90, 0x60, 0x60, 0x90, 0x90,
    // 0x79 - y
    0x00, 0x90, 0x90, 0x70, 0x10, 0x60,
    // 0x7A - z
    0x00, 0xF0, 0x20, 0x40, 0x80, 0xF0,
    // 0x7B - {
    0x30, 0x40, 0xC0, 0xC0, 0x40, 0x30,
    // 0x7C - |
    0x40, 0x40, 0x00, 0x40, 0x40, 0x40,
    // 0x7D - }
    0xC0, 0x20, 0x30, 0x30, 0x20, 0xC0,
    // 0x7E - ~
    0x50, 0xA0, 0x00, 0x00, 0x00, 0x00,
    // 0x7F - DEL (house)
    0x20, 0x70, 0xF0, 0xF0, 0x00, 0x00,
    // 0x80-0xFF: Extended ASCII (simplified versions)
    // 0x80 - Ç
    0x60, 0x80, 0x80, 0x60, 0x20, 0x40,
    // 0x81 - ü
    0xA0, 0x00, 0x90, 0x90, 0x90, 0x70,
    // 0x82 - é
    0x20, 0x40, 0x60, 0xF0, 0x80, 0x70,
    // 0x83 - â
    0x60, 0x00, 0x70, 0x90, 0x90, 0x70,
    // 0x84 - ä
    0xA0, 0x00, 0x70, 0x90, 0x90, 0x70,
    // 0x85 - à
    0x80, 0x40, 0x70, 0x90, 0x90, 0x70,
    // 0x86 - å
    0x40, 0xA0, 0x70, 0x90, 0x90, 0x70,
    // 0x87 - ç
    0x00, 0x70, 0x80, 0x70, 0x20, 0x40,
    // 0x88 - ê
    0x60, 0x00, 0x60, 0xF0, 0x80, 0x70,
    // 0x89 - ë
    0xA0, 0x00, 0x60, 0xF0, 0x80, 0x70,
    // 0x8A - è
    0x80, 0x40, 0x60, 0xF0, 0x80, 0x70,
    // 0x8B - ï
    0xA0, 0x00, 0xC0, 0x40, 0x40, 0xE0,
    // 0x8C - î
    0x40, 0xA0, 0xC0, 0x40, 0x40, 0xE0,
    // 0x8D - ì
    0x80, 0x40, 0xC0, 0x40, 0x40, 0xE0,
    // 0x8E - Ä
    0xA0, 0x60, 0x90, 0xF0, 0x90, 0x90,
    // 0x8F - Å
    0x40, 0xA0, 0x60, 0x90, 0xF0, 0x90,
    // 0x90 - É
    0x20, 0xF0, 0x80, 0xE0, 0x80, 0xF0,
    // 0x91 - æ
    0x00, 0x70, 0xB0, 0xE0, 0xA0, 0x70,
    // 0x92 - Æ
    0x70, 0xA0, 0xA0, 0xF0, 0xA0, 0xB0,
    // 0x93 - ô
    0x60, 0x00, 0x60, 0x90, 0x90, 0x60,
    // 0x94 - ö
    0xA0, 0x00, 0x60, 0x90, 0x90, 0x60,
    // 0x95 - ò
    0x80, 0x40, 0x60, 0x90, 0x90, 0x60,
    // 0x96 - û
    0x60, 0x00, 0x90, 0x90, 0x90, 0x70,
    // 0x97 - ù
    0x80, 0x40, 0x90, 0x90, 0x90, 0x70,
    // 0x98 - ÿ
    0xA0, 0x00, 0x90, 0x70, 0x10, 0x60,
    // 0x99 - Ö
    0xA0, 0x60, 0x90, 0x90, 0x90, 0x60,
    // 0x9A - Ü
    0xA0, 0x00, 0x90, 0x90, 0x90, 0x60,
    // 0x9B - ¢
    0x40, 0x70, 0xA0, 0xA0, 0x70, 0x40,
    // 0x9C - £
    0x30, 0x40, 0xE0, 0x40, 0x40, 0xF0,
    // 0x9D - ¥
    0xA0, 0xA0, 0x40, 0xE0, 0x40, 0x40,
    // 0x9E - ₧
    0xE0, 0xA0, 0xE0, 0xA0, 0xB0, 0xA0,
    // 0x9F - ƒ
    0x30, 0x40, 0xE0, 0x40, 0x40, 0x80,
    // 0xA0 - á
    0x20, 0x40, 0x70, 0x90, 0x90, 0x70,
    // 0xA1 - í
    0x20, 0x40, 0xC0, 0x40, 0x40, 0xE0,
    // 0xA2 - ó
    0x20, 0x40, 0x60, 0x90, 0x90, 0x60,
    // 0xA3 - ú
    0x20, 0x40, 0x90, 0x90, 0x90, 0x70,
    // 0xA4 - ñ
    0x50, 0xA0, 0xE0, 0x90, 0x90, 0x90,
    // 0xA5 - Ñ
    0x50, 0xA0, 0x90, 0xD0, 0xB0, 0x90,
    // 0xA6 - ª
    0x70, 0xB0, 0x70, 0x00, 0xF0, 0x00,
    // 0xA7 - º
    0x60, 0x90, 0x60, 0x00, 0xF0, 0x00,
    // 0xA8 - ¿
    0x40, 0x00, 0x40, 0x80, 0x90, 0x60,
    // 0xA9 - ⌐
    0x00, 0x00, 0xF0, 0x80, 0x80, 0x00,
    // 0xAA - ¬
    0x00, 0x00, 0xF0, 0x10, 0x10, 0x00,
    // 0xAB - ½
    0x80, 0x90, 0xA0, 0x70, 0xB0, 0x10,
    // 0xAC - ¼
    0x80, 0x90, 0xA0, 0x50, 0xB0, 0x10,
    // 0xAD - ¡
    0x40, 0x00, 0x40, 0x40, 0x40, 0x40,
    // 0xAE - «
    0x00, 0x50, 0xA0, 0x50, 0x00, 0x00,
    // 0xAF - »
    0x00, 0xA0, 0x50, 0xA0, 0x00, 0x00,
    // 0xB0 - ░ (light shade)
    0x50, 0xA0, 0x50, 0xA0, 0x50, 0xA0,
    // 0xB1 - ▒ (medium shade)
    0xA0, 0x50, 0xA0, 0x50, 0xA0, 0x50,
    // 0xB2 - ▓ (dark shade)
    0xA0, 0xF0, 0xA0, 0xF0, 0xA0, 0xF0,
    // 0xB3 - │ (vertical line)
    0x40, 0x40, 0x40, 0x40, 0x40, 0x40,
    // 0xB4 - ┤
    0x40, 0x40, 0xC0, 0x40, 0x40, 0x40,
    // 0xB5 - ╡
    0x40, 0xC0, 0x40, 0xC0, 0x40, 0x40,
    // 0xB6 - ╢
    0xA0, 0xA0, 0xE0, 0xA0, 0xA0, 0xA0,
    // 0xB7 - ╖
    0x00, 0x00, 0xE0, 0xA0, 0xA0, 0xA0,
    // 0xB8 - ╕
    0x00, 0xC0, 0x40, 0xC0, 0x40, 0x40,
    // 0xB9 - ╣
    0xA0, 0xE0, 0x20, 0xE0, 0xA0, 0xA0,
    // 0xBA - ║ (double vertical)
    0xA0, 0xA0, 0xA0, 0xA0, 0xA0, 0xA0,
    // 0xBB - ╗
    0x00, 0xE0, 0x20, 0xE0, 0xA0, 0xA0,
    // 0xBC - ╝
    0xA0, 0xE0, 0x20, 0xE0, 0x00, 0x00,
    // 0xBD - ╜
    0xA0, 0xA0, 0xE0, 0x00, 0x00, 0x00,
    // 0xBE - ╛
    0x40, 0xC0, 0x40, 0xC0, 0x00, 0x00,
    // 0xBF - ┐
    0x00, 0x00, 0xC0, 0x40, 0x40, 0x40,
    // 0xC0 - └
    0x40, 0x40, 0x70, 0x00, 0x00, 0x00,
    // 0xC1 - ┴
    0x40, 0x40, 0xF0, 0x00, 0x00, 0x00,
    // 0xC2 - ┬
    0x00, 0x00, 0xF0, 0x40, 0x40, 0x40,
    // 0xC3 - ├
    0x40, 0x40, 0x70, 0x40, 0x40, 0x40,
    // 0xC4 - ─ (horizontal line)
    0x00, 0x00, 0xF0, 0x00, 0x00, 0x00,
    // 0xC5 - ┼
    0x40, 0x40, 0xF0, 0x40, 0x40, 0x40,
    // 0xC6 - ╞
    0x40, 0x70, 0x40, 0x70, 0x40, 0x40,
    // 0xC7 - ╟
    0xA0, 0xA0, 0xB0, 0xA0, 0xA0, 0xA0,
    // 0xC8 - ╚
    0xA0, 0xB0, 0x30, 0x00, 0x00, 0x00,
    // 0xC9 - ╔
    0x00, 0x30, 0xB0, 0xA0, 0xA0, 0xA0,
    // 0xCA - ╩
    0xA0, 0xF0, 0x00, 0x00, 0x00, 0x00,
    // 0xCB - ╦
    0x00, 0x00, 0xF0, 0xA0, 0xA0, 0xA0,
    // 0xCC - ╠
    0xA0, 0xB0, 0x30, 0xB0, 0xA0, 0xA0,
    // 0xCD - ═ (double horizontal)
    0x00, 0xF0, 0x00, 0xF0, 0x00, 0x00,
    // 0xCE - ╬
    0xA0, 0xF0, 0x00, 0xF0, 0xA0, 0xA0,
    // 0xCF - ╧
    0x40, 0xF0, 0x00, 0xF0, 0x00, 0x00,
    // 0xD0 - ╨
    0xA0, 0xA0, 0xF0, 0x00, 0x00, 0x00,
    // 0xD1 - ╤
    0x00, 0xF0, 0x00, 0xF0, 0x40, 0x40,
    // 0xD2 - ╥
    0x00, 0x00, 0xF0, 0xA0, 0xA0, 0xA0,
    // 0xD3 - ╙
    0xA0, 0xA0, 0x30, 0x00, 0x00, 0x00,
    // 0xD4 - ╘
    0x40, 0x70, 0x00, 0x70, 0x00, 0x00,
    // 0xD5 - ╒
    0x00, 0x70, 0x40, 0x70, 0x40, 0x40,
    // 0xD6 - ╓
    0x00, 0x00, 0x30, 0xA0, 0xA0, 0xA0,
    // 0xD7 - ╫
    0xA0, 0xA0, 0xF0, 0xA0, 0xA0, 0xA0,
    // 0xD8 - ╪
    0x40, 0xF0, 0x40, 0xF0, 0x40, 0x40,
    // 0xD9 - ┘
    0x40, 0x40, 0xC0, 0x00, 0x00, 0x00,
    // 0xDA - ┌
    0x00, 0x00, 0x70, 0x40, 0x40, 0x40,
    // 0xDB - █ (full block)
    0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0,
    // 0xDC - ▄ (lower half)
    0x00, 0x00, 0x00, 0xF0, 0xF0, 0xF0,
    // 0xDD - ▌ (left half)
    0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0,
    // 0xDE - ▐ (right half)
    0x30, 0x30, 0x30, 0x30, 0x30, 0x30,
    // 0xDF - ▀ (upper half)
    0xF0, 0xF0, 0xF0, 0x00, 0x00, 0x00,
    // 0xE0 - α
    0x00, 0x70, 0xA0, 0xA0, 0x70, 0x00,
    // 0xE1 - ß
    0x60, 0x90, 0xE0, 0x90, 0xE0, 0x80,
    // 0xE2 - Γ
    0xF0, 0x80, 0x80, 0x80, 0x80, 0x00,
    // 0xE3 - π
    0x00, 0xF0, 0x50, 0x50, 0x50, 0x00,
    // 0xE4 - Σ
    0xF0, 0x40, 0x20, 0x40, 0xF0, 0x00,
    // 0xE5 - σ
    0x00, 0x70, 0xA0, 0xA0, 0x40, 0x00,
    // 0xE6 - µ
    0x00, 0x90, 0x90, 0x90, 0xE0, 0x80,
    // 0xE7 - τ
    0x00, 0xF0, 0x40, 0x40, 0x40, 0x00,
    // 0xE8 - Φ
    0xF0, 0x40, 0xE0, 0x40, 0xF0, 0x00,
    // 0xE9 - Θ
    0x60, 0x90, 0xF0, 0x90, 0x60, 0x00,
    // 0xEA - Ω
    0x60, 0x90, 0x90, 0x60, 0xF0, 0x00,
    // 0xEB - δ
    0x20, 0x40, 0x60, 0x90, 0x60, 0x00,
    // 0xEC - ∞
    0x00, 0xF0, 0xA0, 0xF0, 0x00, 0x00,
    // 0xED - φ
    0x20, 0x70, 0xA0, 0x70, 0x80, 0x00,
    // 0xEE - ε
    0x60, 0x80, 0xC0, 0x80, 0x60, 0x00,
    // 0xEF - ∩
    0x60, 0x90, 0x90, 0x90, 0x90, 0x00,
    // 0xF0 - ≡
    0xF0, 0x00, 0xF0, 0x00, 0xF0, 0x00,
    // 0xF1 - ±
    0x40, 0xE0, 0x40, 0x00, 0xE0, 0x00,
    // 0xF2 - ≥
    0x80, 0x40, 0x80, 0x00, 0xF0, 0x00,
    // 0xF3 - ≤
    0x20, 0x40, 0x20, 0x00, 0xF0, 0x00,
    // 0xF4 - ⌠
    0x30, 0x40, 0x40, 0x40, 0x40, 0x40,
    // 0xF5 - ⌡
    0x40, 0x40, 0x40, 0x40, 0xC0, 0x00,
    // 0xF6 - ÷
    0x40, 0x00, 0xE0, 0x00, 0x40, 0x00,
    // 0xF7 - ≈
    0x50, 0xA0, 0x00, 0x50, 0xA0, 0x00,
    // 0xF8 - °
    0x60, 0x90, 0x60, 0x00, 0x00, 0x00,
    // 0xF9 - ∙
    0x00, 0x00, 0x60, 0x60, 0x00, 0x00,
    // 0xFA - ·
    0x00, 0x00, 0x00, 0x40, 0x00, 0x00,
    // 0xFB - √
    0x30, 0x20, 0x20, 0xA0, 0x60, 0x20,
    // 0xFC - ⁿ
    0xE0, 0x50, 0x50, 0x00, 0x00, 0x00,
    // 0xFD - ²
    0xE0, 0x20, 0x60, 0xE0, 0x00, 0x00,
    // 0xFE - ■ (filled square)
    0x00, 0x60, 0x60, 0x60, 0x00, 0x00,
    // 0xFF - nbsp
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
];

// ============================================================================
// Character Index Mapping
// ============================================================================

/// Down arrow character (special case - use this instead of 'v' for arrow)
pub const DOWN_ARROW: u8 = 0x19; // Using a control char that won't conflict

/// Map an ASCII character to its font index
///
/// # Arguments
/// * `ch` - ASCII character byte
///
/// # Returns
/// Font index (same as input for this font)
#[inline(never)]
pub fn char_to_index(ch: u8) -> usize {
    ch as usize
}

/// Get the bitmap data for a character as a fixed-size array (by value)
///
/// # Arguments
/// * `ch` - ASCII character byte
///
/// # Returns
/// Array of 6 bytes representing the character bitmap (copied by value)
#[inline(never)]
pub fn get_char_bitmap(ch: u8) -> [u8; 6] {
    let start = (ch as usize) * CHAR_HEIGHT;
    [
        FONT_DATA[start],
        FONT_DATA[start + 1],
        FONT_DATA[start + 2],
        FONT_DATA[start + 3],
        FONT_DATA[start + 4],
        FONT_DATA[start + 5],
    ]
}

// ============================================================================
// Buffer-Based Rendering (for mode13h.rs and offscreen buffers)
// ============================================================================

/// Draw a character bitmap to a buffer
#[inline]
fn draw_bitmap_to_buffer(
    buffer: &mut [u8],
    x: usize,
    y: usize,
    bitmap: [u8; 6],
    color: u8,
) {
    for (row, bits) in bitmap.iter().enumerate().take(CHAR_HEIGHT) {
        let py = y + row;
        for col in 0..CHAR_WIDTH {
            // Top 4 bits contain pixel data, MSB = leftmost
            if (bits >> (7 - col)) & 1 != 0 {
                let px = x + col;
                let offset = py * SCREEN_WIDTH + px;
                if offset < buffer.len() {
                    buffer[offset] = color;
                }
            }
        }
    }
}

/// Draw a character bitmap to a buffer with background color
#[inline]
fn draw_bitmap_to_buffer_bg(
    buffer: &mut [u8],
    x: usize,
    y: usize,
    bitmap: [u8; 6],
    fg: u8,
    bg: u8,
) {
    for (row, bits) in bitmap.iter().enumerate().take(CHAR_HEIGHT) {
        let py = y + row;
        for col in 0..CHAR_WIDTH {
            let px = x + col;
            let offset = py * SCREEN_WIDTH + px;
            if offset < buffer.len() {
                buffer[offset] = if (bits >> (7 - col)) & 1 != 0 { fg } else { bg };
            }
        }
    }
}

/// Draw a single character to a buffer (foreground only)
///
/// This is the primary buffer-based draw_char used by mode13h.rs
pub fn draw_char(buffer: &mut [u8], x: usize, y: usize, ch: u8, fg: u8) {
    let bitmap = get_char_bitmap(ch);
    draw_bitmap_to_buffer(buffer, x, y, bitmap, fg);
}

/// Draw a single character to a buffer with background color
pub fn draw_char_bg(buffer: &mut [u8], x: usize, y: usize, ch: u8, fg: u8, bg: u8) {
    let bitmap = get_char_bitmap(ch);
    draw_bitmap_to_buffer_bg(buffer, x, y, bitmap, fg, bg);
}

/// Draw a string to a buffer (foreground only)
pub fn draw_str(buffer: &mut [u8], x: usize, y: usize, s: &str, fg: u8) {
    let mut cx = x;
    for ch in s.bytes() {
        draw_char(buffer, cx, y, ch, fg);
        cx += CELL_WIDTH;
    }
}

/// Draw a &str string to a buffer (foreground only) - alias for draw_str
pub fn draw_string(buffer: &mut [u8], x: usize, y: usize, s: &str, fg: u8) {
    draw_str(buffer, x, y, s, fg);
}

/// Draw a byte slice to a buffer (stops at null)
pub fn draw_bytes(buffer: &mut [u8], x: usize, y: usize, s: &[u8], fg: u8) {
    let mut cx = x;
    for &ch in s {
        if ch == 0 { break; }
        draw_char(buffer, cx, y, ch, fg);
        cx += CELL_WIDTH;
    }
}

/// Draw a string to a buffer with background color
pub fn draw_str_bg(buffer: &mut [u8], x: usize, y: usize, s: &str, fg: u8, bg: u8) {
    let mut cx = x;
    for ch in s.bytes() {
        draw_char_bg(buffer, cx, y, ch, fg, bg);
        cx += CELL_WIDTH;
    }
}

/// Draw a string centered horizontally to a buffer
pub fn draw_string_centered(buffer: &mut [u8], y: usize, s: &str, fg: u8) {
    let width = s.len() * CELL_WIDTH;
    let x = (SCREEN_WIDTH.saturating_sub(width)) / 2;
    draw_str(buffer, x, y, s, fg);
}

/// Draw an unsigned number to a buffer
pub fn draw_number(buffer: &mut [u8], x: usize, y: usize, n: u32, min_width: usize, fg: u8) {
    let mut digits = [0u8; 10];
    let mut num = n;
    let mut count = 0;

    // Extract digits (reverse order)
    loop {
        digits[count] = b'0' + (num % 10) as u8;
        count += 1;
        num /= 10;
        if num == 0 {
            break;
        }
    }

    // Pad with spaces if needed
    let mut cx = x;
    if count < min_width {
        for _ in 0..(min_width - count) {
            draw_char(buffer, cx, y, b' ', fg);
            cx += CELL_WIDTH;
        }
    }

    // Draw digits in correct order
    for i in (0..count).rev() {
        draw_char(buffer, cx, y, digits[i], fg);
        cx += CELL_WIDTH;
    }
}

/// Draw a signed number to a buffer
pub fn draw_signed(buffer: &mut [u8], x: usize, y: usize, n: i32, min_width: usize, fg: u8) {
    let mut cx = x;
    if n < 0 {
        draw_char(buffer, cx, y, b'-', fg);
        cx += CELL_WIDTH;
        draw_number(buffer, cx, y, (-n) as u32, min_width.saturating_sub(1), fg);
    } else {
        draw_number(buffer, cx, y, n as u32, min_width, fg);
    }
}

/// Draw a hexadecimal number to a buffer
pub fn draw_hex(buffer: &mut [u8], x: usize, y: usize, n: u32, digits: usize, fg: u8) {
    const HEX_CHARS: &[u8] = b"0123456789ABCDEF";
    let mut cx = x;
    for i in (0..digits).rev() {
        let nibble = ((n >> (i * 4)) & 0xF) as usize;
        draw_char(buffer, cx, y, HEX_CHARS[nibble], fg);
        cx += CELL_WIDTH;
    }
}

/// Calculate the pixel width of a string
#[inline]
pub fn string_width(s: &str) -> usize {
    if s.is_empty() {
        0
    } else {
        s.len() * CELL_WIDTH - CHAR_SPACING
    }
}

/// Calculate the pixel width of a byte string (stops at null)
#[inline]
pub fn bytes_width(s: &[u8]) -> usize {
    let len = s.iter().position(|&c| c == 0).unwrap_or(s.len());
    if len == 0 {
        0
    } else {
        len * CELL_WIDTH - CHAR_SPACING
    }
}

/// Calculate how many characters fit in a given pixel width
#[inline]
pub fn chars_in_width(pixels: usize) -> usize {
    if pixels < CHAR_WIDTH {
        0
    } else {
        (pixels + CHAR_SPACING) / CELL_WIDTH
    }
}

// ============================================================================
// VGA-Direct Rendering (for rom_browser.rs - writes directly to VGA memory)
// ============================================================================

/// Draw a single character directly to VGA memory
#[inline(never)]
pub fn draw_char_vga(x: usize, y: usize, ch: u8, color: u8) {
    let bitmap = get_char_bitmap(ch);
    vga_mode13h::draw_bitmap_4x6(x, y, bitmap, color);
}

/// Draw a string directly to VGA memory
#[inline(never)]
pub fn draw_string_vga(x: usize, y: usize, s: &str, color: u8) {
    let mut cx = x;
    for ch in s.bytes() {
        draw_char_vga(cx, y, ch, color);
        cx += CELL_WIDTH;
    }
}

/// Draw a string centered horizontally, directly to VGA memory
#[inline(never)]
pub fn draw_string_centered_vga(y: usize, s: &str, color: u8) {
    let width = s.len() * CELL_WIDTH;
    let x = (SCREEN_WIDTH.saturating_sub(width)) / 2;
    draw_string_vga(x, y, s, color);
}
